<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>CF 723D - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="stylesheet" type="text/css" href="/codes/style.css" />
	</head>
	<body>
		<h2 align="center">CF 723D</h2>
		<time>2018-03-06 21:21 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/CodeForces-723D">vjudge</a>
			<a target="_blank" href="http://codeforces.com/problemset/problem/723/D">Codeforces</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem required us to find out all the lakes, and according to the greedy algorithm, we will fill the smallest lakes with land until there are only <var>#k#</var> of them left. But the problem is how to find out all the lakes. The answer is <abbr title="Depth-First Search">DFS</abbr>. What's more, you'll find the data range is just <var>1&le;#n#, #m#&le;50, 0&le;#k#&le;50</var>. So what else do we need to worry about? The simulation is very enough. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`island:array[1..50,1..50]of integer;
				`lakex,lakey,size:array[1..2500]of integer;
				`lake,n,m,k,i,j,ans:integer;
				`s:string;
				procedure qsort(l,r:integer);//Sort the lakes according to their sizes
				var
				`x,y,std,tmp:integer;
				begin
				`x:=l;
				`y:=r;
				`std:=size[(l+r) div 2];
				`while x&lt;y do
				``begin
				```while size[x]&lt;std do
				````inc(x);
				```while size[y]&gt;std do
				````dec(y);
				```if x&lt;=y then
				````begin
				`````tmp:=size[x];//Exchange the lakes' information
				`````size[x]:=size[y];
				`````size[y]:=tmp;
				`````tmp:=lakex[x];
				`````lakex[x]:=lakex[y];
				`````lakex[y]:=tmp;
				`````tmp:=lakey[x];
				`````lakey[x]:=lakey[y];
				`````lakey[y]:=tmp;
				`````inc(x);
				`````dec(y);
				````end;
				``end;
				`if l&lt;y then
				``qsort(l,y);
				`if r&gt;x then
				``qsort(x,r);
				end;
				function search(x,y:integer):integer;//Search the whole district to get the size of the lake
				var
				`tmp:integer;
				begin
				`if (island[x+1][y]=-10000)or(island[x-1][y]=-10000)//If it is next to the sea, it is the sea too
				`or(island[x][y+1]=-10000)or(island[x][y-1]=-10000) then
				``exit(-10000);
				`island[x,y]:=-2;//Mark the water that has been counted
				`tmp:=1;
				`if island[x+1,y]=0 then//Search the water around
				``tmp+=search(x+1,y);
				`if island[x-1,y]=0 then
				``tmp+=search(x-1,y);
				`if island[x,y+1]=0 then
				``tmp+=search(x,y+1);
				`if island[x,y-1]=0 then
				``tmp+=search(x,y-1);
				`if tmp&lt;0 then//If it is connected to water which is next to the sea, it is the sea too
				``exit(-10000);
				`exit(tmp);
				end;
				procedure fill(x,y,mark,key:integer);//Fill the lake with the mark and the key is the mark which it used to be
				begin
				`island[x,y]:=mark;
				`if island[x+1,y]=key then
				``fill(x+1,y,mark,key);
				`if island[x-1,y]=key then
				``fill(x-1,y,mark,key);
				`if island[x,y+1]=key then
				``fill(x,y+1,mark,key);
				`if island[x,y-1]=key then
				``fill(x,y-1,mark,key);
				end;
				begin
				`lake:=0;
				`ans:=0;
				`readln(n,m,k);
				`for i:=1 to n do//Read the map of the island
				``begin
				```readln(s);
				```for j:=1 to m do
				````if s[j]='*' then//-1 means land, -10000 means sea, 0 means water
				`````island[i,j]:=-1
				````else
				`````if (i=1)or(j=1)or(i=n)or(j=m) then
				``````island[i,j]:=-10000
				`````else
				``````island[i,j]:=0;
				``end;
				`for i:=1 to n do//Find all the lakes on the island
				``for j:=1 to m do
				```if island[i,j]=0 then
				````begin
				`````fill(i,j,search(i,j),-2);
				`````if island[i,j]&gt;0 then//Keep the lakes' information
				``````begin
				```````inc(lake);
				```````lakex[lake]:=i;
				```````lakey[lake]:=j;
				```````size[lake]:=island[i,j];
				``````end;
				````end;
				`qsort(1,lake);
				`for i:=1 to lake-k do//Fill the smallest lakes with land
				``begin
				```ans:=ans+size[i];
				```fill(lakex[i],lakey[i],-1,size[i]);
				``end;
				`writeln(ans);
				`for i:=1 to n do
				``begin
				```for j:=1 to m do
				````if island[i,j]=-1 then
				`````write('*')
				````else
				`````write('.');
				```writeln;
				``end;
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				int island[50][50],lakex[2500],lakey[2500],size[2500],lake=0,n,m;
				char s[51];
				void qsort(int l,int r)//Sort the lakes according to their sizes
				{
				`int x=l,y=r,std=size[(l+r)/2];
				`while(x&lt;y)
				`{
				``while(size[x]&lt;std)
				```x++;
				``while(size[y]&gt;std)
				```y--;
				``if(x&lt;=y)
				``{
				```int tmp=size[x];//Exchange the lakes' information
				```size[x]=size[y];
				```size[y]=tmp;
				```tmp=lakex[x];
				```lakex[x]=lakex[y];
				```lakex[y]=tmp;
				```tmp=lakey[x];
				```lakey[x]=lakey[y];
				```lakey[y]=tmp;
				```x++;
				```y--;
				``}
				`}
				`if(l&lt;y)
				``qsort(l,y);
				`if(r&gt;x)
				``qsort(x,r);
				}
				int search(int x,int y)//Search the whole district to get the size of the lake
				{
				`if((island[x+1][y]==-10000)||(island[x-1][y]==-10000)//If it is next to the sea, it is the sea too
				`||(island[x][y+1]==-10000)||(island[x][y-1]==-10000))
				``return -10000;
				`island[x][y]=-2;//Mark the water that has been counted
				`int tmp=1;
				`if(island[x+1][y]==0)//Search the water around
				``tmp+=search(x+1,y);
				`if(island[x-1][y]==0)
				``tmp+=search(x-1,y);
				`if(island[x][y+1]==0)
				``tmp+=search(x,y+1);
				`if(island[x][y-1]==0)
				``tmp+=search(x,y-1);
				`if(tmp&lt;0)//If it is connected to water which is next to the sea, it is the sea too
				``return -10000;
				`return tmp;
				}
				void fill(int x,int y,int mark,int key)//Fill the lake with the mark and the key is the mark which it used to be
				{
				`island[x][y]=mark;
				`if(island[x+1][y]==key)
				``fill(x+1,y,mark,key);
				`if(island[x-1][y]==key)
				``fill(x-1,y,mark,key);
				`if(island[x][y+1]==key)
				``fill(x,y+1,mark,key);
				`if(island[x][y-1]==key)
				``fill(x,y-1,mark,key);
				}
				int main()
				{
				`int k,ans=0;
				`scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
				`for(int i=0;i&lt;n;i++)//Read the map of the island
				`{
				``scanf("%s",&amp;s);
				``for(int j=0;j&lt;m;j++)
				```if(s[j]=='*')//-1 means land, -10000 means sea, 0 means water
				````island[i][j]=-1;
				```else
				````if((i==0)||(j==0)||(i==n-1)||(j==m-1))
				`````island[i][j]=-10000;
				````else
				`````island[i][j]=0;
				`}
				`for(int i=0;i&lt;n;i++)//Find all the lakes on the island
				``for(int j=0;j&lt;m;j++)
				```if(island[i][j]==0)
				```{
				````fill(i,j,search(i,j),-2);
				````if(island[i][j]&gt;0)//Keep the lakes' information
				````{
				`````lakex[lake]=i;
				`````lakey[lake]=j;
				`````size[lake]=island[i][j];
				`````lake++;
				````}
				```}
				`qsort(0,lake-1);
				`for(int i=0;i&lt;lake-k;i++)//Fill the smallest lakes with land
				`{
				``ans+=size[i];
				``fill(lakex[i],lakey[i],-1,size[i]);
				`}
				`printf("%d\n",ans);
				`for(int i=0;i&lt;n;i++)
				`{
				``for(int j=0;j&lt;m;j++)
				```if(island[i][j]==-1)
				````putchar('*');
				```else
				````putchar('.');
				``putchar('\n');
				`}
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
