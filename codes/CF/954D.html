<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>CF 954D - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="stylesheet" type="text/css" href="/codes/style.css" />
	</head>
	<body>
		<h2 align="center">CF 954D</h2>
		<time>2018-09-24 14:23 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/CodeForces-954D">vjudge</a>
			<a target="_blank" href="https://codeforces.com/problemset/problem/954/D">Codeforces</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem is a good practice of <abbr title="Shortest Path Faster Algorithm">SPFA</abbr>. To solve the problem, you can run SPFA twice to find the distance to <var>#s#</var> and <var>#t#</var> of each point. Then you can enumerate the point pairs and check whether you can add an edge here. But remember to skip or remove the edges which already exist. The total time complexity is <var>O(#n#(^2^))</var>. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`des,nxt:array[1..2000]of integer;
				`h,dis_s,dis_t,queue:array[1..1000]of integer;
				`inqueue:array[1..1000]of boolean;
				`n,m,s,t,i,u,v,p,ans:integer;
				begin
				`read(n,m,s,t);
				`for i:=1 to n do//Initialize arrays
				``begin
				```dis_s[i]:=maxint;
				```dis_t[i]:=maxint;
				```h[i]:=-1;
				```inqueue[i]:=false;
				``end;
				`for i:=1 to m do//Read the edges
				``begin
				```read(u,v);
				```nxt[2*i-1]:=h[u];
				```nxt[2*i]:=h[v];
				```des[2*i-1]:=v;
				```des[2*i]:=u;
				```h[u]:=2*i-1;
				```h[v]:=2*i;
				``end;
				`queue[1]:=s;//Use SPFA to find the distance to s
				`inqueue[s]:=true;
				`dis_s[s]:=0;
				`u:=1;//u is the head of the queue and v is the foot
				`v:=2;
				`while u&lt;&gt;v do
				``begin
				```p:=queue[u];
				```u:=u mod 1000+1;
				```inqueue[p]:=false;
				```i:=h[p];
				```while i&lt;&gt;-1 do
				````begin
				`````if dis_s[des[i]]&gt;dis_s[p]+1 then
				``````begin
				```````dis_s[des[i]]:=dis_s[p]+1;
				```````if not(inqueue[des[i]]) then
				````````begin
				`````````queue[v]:=des[i];
				`````````v:=v mod 1000+1;
				`````````inqueue[des[i]]:=true;
				````````end;
				``````end;
				`````i:=nxt[i];
				````end;
				``end;
				`queue[1]:=t;//Use SPFA to find the distance to t
				`inqueue[t]:=true;
				`dis_t[t]:=0;
				`u:=1;
				`v:=2;
				`while u&lt;&gt;v do
				``begin
				```p:=queue[u];
				```u:=u mod 1000+1;
				```inqueue[p]:=false;
				```i:=h[p];
				```while i&lt;&gt;-1 do
				````begin
				`````if dis_t[des[i]]&gt;dis_t[p]+1 then
				``````begin
				```````dis_t[des[i]]:=dis_t[p]+1;
				```````if not(inqueue[des[i]]) then
				````````begin
				`````````queue[v]:=des[i];
				`````````v:=v mod 1000+1;
				`````````inqueue[des[i]]:=true;
				````````end;
				``````end;
				`````i:=nxt[i];
				````end;
				``end;
				`ans:=0;
				`for u:=1 to n do//Enumerate the pairs to find the possible edges
				``for v:=1 to u-1 do
				```if (dis_s[u]+dis_t[v]+1&gt;=dis_s[t])and(dis_t[u]+dis_s[v]+1&gt;=dis_t[s]) then//Both dis_s[t] and dis_t[s] mean the distance between s and t
				````inc(ans);
				`write(ans-m);//Remove the edges that already exist
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				int des[2000],nxt[2000],h[1000],dis_s[1000],dis_t[1000],queue[1000],inqueue[1000];
				int main()
				{
				`int n,m,s,t;
				`scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t);
				`s--;//The point numbers are from 0 to n-1 in the program while they are from 1 to n in the problem
				`t--;
				`for(int i=0;i&lt;n;i++)//Initialize arrays
				`{
				``dis_s[i]=dis_t[i]=65535;
				``h[i]=-1;
				``inqueue[i]=0;
				`}
				`for(int i=0,u,v;i&lt;m;i++)//Read the edges
				`{
				``scanf("%d%d",&amp;u,&amp;v);
				``u--;
				``v--;
				``nxt[2*i]=h[u];
				``nxt[2*i+1]=h[v];
				``des[2*i]=v;
				``des[2*i+1]=u;
				``h[u]=2*i;
				``h[v]=2*i+1;
				`}
				`queue[0]=s;//Use SPFA to find the distance to s
				`inqueue[s]=1;
				`dis_s[s]=0;
				`for(int u=0,v=1;u!=v;)//u is the head of the queue and v is the foot
				`{
				``int p=queue[u++];
				``u%=1000;
				``inqueue[p]=0;
				``for(int i=h[p];i!=-1;i=nxt[i])
				```if(dis_s[des[i]]&gt;dis_s[p]+1)
				```{
				````dis_s[des[i]]=dis_s[p]+1;
				````if(inqueue[des[i]]==0)
				````{
				`````queue[v++]=des[i];
				`````v%=1000;
				`````inqueue[des[i]]=1;
				````}
				```}
				`}
				`queue[0]=t;//Use SPFA to find the distance to t
				`inqueue[t]=1;
				`dis_t[t]=0;
				`for(int u=0,v=1;u!=v;)
				`{
				``int p=queue[u++];
				``u%=1000;
				``inqueue[p]=0;
				``for(int i=h[p];i!=-1;i=nxt[i])
				```if(dis_t[des[i]]&gt;dis_t[p]+1)
				```{
				````dis_t[des[i]]=dis_t[p]+1;
				````if(inqueue[des[i]]==0)
				````{
				`````queue[v++]=des[i];
				`````v%=1000;
				`````inqueue[des[i]]=1;
				````}
				```}
				`}
				`int ans=0;
				`for(int u=0;u&lt;n;u++)//Enumerate the pairs to find the possible edges
				``for(int v=0;v&lt;u;v++)
				```if((dis_s[u]+dis_t[v]+1&gt;=dis_s[t])&amp;&amp;(dis_t[u]+dis_s[v]+1&gt;=dis_t[s]))//Both dis_s[t] and dis_t[s] mean the distance between s and t
				````ans++;
				`printf("%d",ans-m);//Remove the edges that already exist
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
