<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>CF 950C - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="stylesheet" type="text/css" href="/codes/style.css" />
	</head>
	<body>
		<h2 align="center">CF 950C</h2>
		<time>2018-03-12 19:38 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/CodeForces-950C">vjudge</a>
			<a target="_blank" href="http://codeforces.com/problemset/problem/950/C">Codeforces</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem is as difficult as the second problem in Senior Group, NOIp. It is not hard to understand the problem. What you are asked to do is to check if a 01 string can be divided into serval zebra sequences, which start and end with '0', and there is always a '0' between two '1', and an '1' between two '0'. </p>
			<p>You can use an adjacency table to keep the zebra sequences. So you can add a char to a sequence in <var>O(1)</var>. Then you scan the string. When you find a char, put it at the end of a sequence ends with another char. When all the sequences end with '0' and you find another '0', just create another zebra sequence. But if you find all the sequences end with '1' and there is another '1' waiting, that means it is impossible to divide the 01 string into serval zebra sequences because there are too many '1'. As a result, you had to print -1. </p>
			<p>Don't forget to check if all the sequences end with '0'. If any of them end with '1', the answer will be -1 too because there is an invalid zebra sequence. I got a <abbr title="Wrong Answer">WA</abbr> because of this. </p>
			<p>By the way, if you just hand the code as the solution above just like Solution 1 in the code part, you'll receive a <abbr title="Time Limit Exceeded">TLE</abbr>. I received one too. You spent too much time finding the suitable sequence. The regular way is <var>O(length(#s#))</var>. You need two queues to put the sequences inside so that you can find the suitable sequences in <var>O(1)</var>. Solution 2 in the code part is an example of this. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Solution 1 Pascal</p>
			<code>
				var
				`s:ansistring;
				`h,f,nxt,len:array[1..300000]of longint;//The array h and the array f are the head and the foot of the adjacency table
				`cnt,i,j:longint;//cnt is the number of the zebra sequences
				`flag:boolean;
				begin
				`readln(s);
				`cnt:=0;
				`for i:=1 to length(s) do
				``begin
				```nxt[i]:=-1;
				```flag:=false;//flag is whether this char has been added to a zebra sequence
				```for j:=1 to cnt do//Enumerate the zebra sequences to find the suitable one
				````if s[f[j]]&lt;&gt;s[i] then
				`````begin
				``````nxt[f[j]]:=i;
				``````f[j]:=i;
				``````inc(len[j]);
				``````flag:=true;
				``````break;
				`````end;
				```if flag then
				````continue;
				```if s[i]='1' then//Too much '1' found so that it is impossible to divide the 01 string into serval zebra sequences
				````begin
				`````write(-1);
				`````halt;
				````end
				```else//Create a new zebra sequence
				````begin
				`````inc(cnt);
				`````h[cnt]:=i;
				`````f[cnt]:=i;
				`````len[cnt]:=1;
				````end;
				``end;
				`for i:=1 to cnt do//Check if there is a zebra sequence ended with '1'
				``if s[f[i]]='1' then
				```begin
				````write(-1);
				````halt;
				```end;
				`writeln(cnt);//Output the answer
				`for i:=1 to cnt do
				``begin
				```write(len[i]);
				```j:=h[i];
				```while j&lt;&gt;-1 do
				````begin
				`````write(' ',j);
				`````j:=nxt[j];
				````end;
				```writeln;
				``end;
				end.
			</code>
			<p>Solution 1 C++</p>
			<code>
				#include&lt;cstdio&gt;
				#include&lt;cstring&gt;//We need to use the strlen function in cstring
				char s[300000];
				long h[300000],f[300000],nxt[300000],len[300000];//The array h and the array f are the head and the foot of the adjacency table
				int main()
				{
				`scanf("%s",&amp;s);
				`long cnt=0;//cnt is the number of the zebra sequences
				`for(long i=0,l=strlen(s);i&lt;l;i++)
				`{
				``nxt[i]=-1;
				``int flag=0;//flag is whether this char has been added to a zebra sequence
				``for(long j=0;j&lt;cnt;j++)//Enumerate the zebra sequences to find the suitable one
				```if(s[f[j]]!=s[i])
				```{
				````nxt[f[j]]=i;
				````f[j]=i;
				````len[j]++;
				````flag=1;
				````break;
				```}
				``if(flag==1)
				```continue;
				``if(s[i]=='1')//Too much '1' found so that it is impossible to divide the 01 string into serval zebra sequences
				``{
				```printf("-1");
				```return 0;
				``}
				``else//Create a new zebra sequence
				``{
				```h[cnt]=f[cnt]=i;
				```len[cnt++]=1;
				``}
				`}
				`for(long i=0;i&lt;cnt;i++)//Check if there is a zebra sequence ended with '1'
				``if(s[f[i]]=='1')
				``{
				```printf("-1");
				```return 0;
				``}
				`printf("%ld",cnt);//Output the answer
				`for(long i=0;i&lt;cnt;i++)
				`{
				``printf("\n%ld",len[i]);
				``for(long j=h[i];j!=-1;j=nxt[j])
				```printf(" %ld",j+1);
				`}
				`return 0;
				}
			</code>
			<p>Solution 2 Pascal</p>
			<code>
				var
				`s:ansistring;
				`h,f,nxt,len:array[1..300000]of longint;
				`queue:array[0..1,1..300000]of longint;
				`head,foot:array[0..1]of longint;
				`cnt,i,j:longint;
				begin
				`readln(s);
				`cnt:=0;
				`head[0]:=1;//Format the queue
				`foot[0]:=0;
				`head[1]:=1;
				`foot[1]:=0;
				`for i:=1 to length(s) do
				``begin
				```nxt[i]:=-1;
				```if head[49-ord(s[i])]&lt;=foot[49-ord(s[i])] then//Use queue to find the suitable zebra sequence in a short time
				````begin
				`````j:=queue[49-ord(s[i]),head[49-ord(s[i])]];
				`````inc(head[49-ord(s[i])]);
				`````nxt[f[j]]:=i;
				`````f[j]:=i;
				`````inc(len[j]);
				`````inc(foot[ord(s[i])-48]);
				`````queue[ord(s[i])-48,foot[ord(s[i])-48]]:=j;
				`````continue;
				````end;
				```if s[i]='1' then
				````begin
				`````write(-1);
				`````halt;
				````end
				```else
				````begin
				`````inc(cnt);
				`````h[cnt]:=i;
				`````f[cnt]:=i;
				`````len[cnt]:=1;
				`````inc(foot[ord(s[i])-48]);
				`````queue[ord(s[i])-48,foot[ord(s[i])-48]]:=cnt;
				````end;
				``end;
				`if head[1]&lt;=foot[1] then//Check whether the queue of '1' is empty to check if there is a zebra sequence ended with '1'
				``begin
				```write(-1);
				```halt;
				``end;
				`writeln(cnt);
				`for i:=1 to cnt do
				``begin
				```write(len[i]);
				```j:=h[i];
				```while j&lt;&gt;-1 do
				````begin
				`````write(' ',j);
				`````j:=nxt[j];
				````end;
				```writeln;
				``end;
				end.
			</code>
			<p>Solution 2 C++</p>
			<code>
				#include&lt;cstdio&gt;
				#include&lt;cstring&gt;//We need to use the strlen function in cstring
				char s[300000];
				long h[300000],f[300000],nxt[300000],len[300000],queue[2][300000],head[2],foot[2];
				int main()
				{
				`scanf("%s",&amp;s);
				`long cnt=0;
				`head[0]=foot[0]=head[1]=foot[1]=0;//Format the queue
				`for(long i=0,l=strlen(s);i&lt;l;i++)
				`{
				``nxt[i]=-1;
				``if(head['1'-s[i]]!=foot['1'-s[i]])//Use queue to find the suitable zebra sequence in a short time
				``{
				```long j=queue['1'-s[i]][head['1'-s[i]]++];
				```nxt[f[j]]=i;
				```f[j]=i;
				```len[j]++;
				```queue[s[i]-'0'][foot[s[i]-'0']++]=j;
				```continue;
				``}
				``if(s[i]=='1')
				``{
				```printf("-1");
				```return 0;
				``}
				``else
				``{
				```h[cnt]=f[cnt]=i;
				```len[cnt]=1;
				```queue[s[i]-'0'][foot[s[i]-'0']++]=cnt++;
				``}
				`}
				`if(head[1]!=foot[1])//Check whether the queue of '1' is empty to check if there is a zebra sequence ended with '1'
				`{
				``printf("-1");
				``return 0;
				`}
				`printf("%ld",cnt);
				`for(long i=0;i&lt;cnt;i++)
				`{
				``printf("\n%ld",len[i]);
				``for(long j=h[i];j!=-1;j=nxt[j])
				```printf(" %ld",j+1);
				`}
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
