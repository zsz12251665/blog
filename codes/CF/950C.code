var
	s:ansistring;
	h,f,nxt,len:array[1..300000]of longint;// The array h and the array f are the head and the foot of the adjacency table
	cnt,i,j:longint;// cnt is the number of the zebra sequences
	is_added:boolean;
begin
	readln(s);
	cnt:=0;
	for i:=1 to length(s) do
		begin
			nxt[i]:=-1;
			is_added:=false;// Whether this char has been added to a zebra sequence
			for j:=1 to cnt do// Enumerate the zebra sequences to find the suitable one
				if s[f[j]]<>s[i] then
					begin
						nxt[f[j]]:=i;
						f[j]:=i;
						inc(len[j]);
						is_added:=true;
						break;
					end;
			if is_added then
				continue;
			if s[i]='1' then// Too many '1's are found to divide the 01 string into serval zebra sequences
				begin
					write(-1);
					halt;
				end
			else// Create a new zebra sequence
				begin
					inc(cnt);
					h[cnt]:=i;
					f[cnt]:=i;
					len[cnt]:=1;
				end;
		end;
	for i:=1 to cnt do// Check if there is a zebra sequence ended with '1'
		if s[f[i]]='1' then
			begin
				write(-1);
				halt;
			end;
	write(cnt);// Output the answer
	for i:=1 to cnt do
		begin
			writeln;
			write(len[i]);
			j:=h[i];
			while j<>-1 do
				begin
					write(' ',j);
					j:=nxt[j];
				end;
		end;
end.

#include<cstdio>
#include<cstring>// We need to use the strlen function in cstring
using namespace std;
char s[300000];
long h[300000],f[300000],nxt[300000],len[300000];// The array h and the array f are the head and the foot of the adjacency table
int main()
{
	scanf("%s",&s);
	long cnt=0;// cnt is the number of the zebra sequences
	for(long i=0,l=strlen(s);i<l;++i)
	{
		nxt[i]=-1;
		bool is_added=false;// Whether this char has been added to a zebra sequence
		for(long j=0;j<cnt;++j)// Enumerate the zebra sequences to find the suitable one
			if(s[f[j]]!=s[i])
			{
				f[j]=nxt[f[j]]=i;
				len[j]++;
				is_added=true;
				break;
			}
		if(is_added)
			continue;
		if(s[i]=='1')// Too many '1's are found to divide the 01 string into serval zebra sequences
		{
			printf("-1");
			return 0;
		}
		else// Create a new zebra sequence
		{
			h[cnt]=f[cnt]=i;
			len[cnt++]=1;
		}
	}
	for(long i=0;i<cnt;++i)// Check if there is a zebra sequence ended with '1'
		if(s[f[i]]=='1')
		{
			printf("-1");
			return 0;
		}
	printf("%ld",cnt);// Output the answer
	for(long i=0;i<cnt;++i)
	{
		printf("\n%ld",len[i]);
		for(long j=h[i];j!=-1;j=nxt[j])
			printf(" %ld",j+1);
	}
	return 0;
}

var
	s:ansistring;
	h,f,nxt,len:array[1..300000]of longint;
	queue:array[0..1,1..300000]of longint;
	head,foot:array[0..1]of longint;
	cnt,i,j:longint;
begin
	readln(s);
	cnt:=0;
	head[0]:=1;// Initialize the queue
	head[1]:=1;
	foot[0]:=0;
	foot[1]:=0;
	for i:=1 to length(s) do
		begin
			nxt[i]:=-1;
			if head[49-ord(s[i])]<=foot[49-ord(s[i])] then// Use queue to find the suitable zebra sequence in a short time
				begin
					j:=queue[49-ord(s[i]),head[49-ord(s[i])]];
					inc(head[49-ord(s[i])]);
					nxt[f[j]]:=i;
					f[j]:=i;
					inc(len[j]);
					inc(foot[ord(s[i])-48]);
					queue[ord(s[i])-48,foot[ord(s[i])-48]]:=j;
					continue;
				end;
			if s[i]='1' then
				begin
					write(-1);
					halt;
				end
			else
				begin
					inc(cnt);
					h[cnt]:=i;
					f[cnt]:=i;
					len[cnt]:=1;
					inc(foot[ord(s[i])-48]);
					queue[ord(s[i])-48,foot[ord(s[i])-48]]:=cnt;
				end;
		end;
	if head[1]<=foot[1] then// Check whether the queue of '1' is empty to check if there is a zebra sequence ended with '1'
		begin
			write(-1);
			halt;
		end;
	write(cnt);
	for i:=1 to cnt do
		begin
			writeln;
			write(len[i]);
			j:=h[i];
			while j<>-1 do
				begin
					write(' ',j);
					j:=nxt[j];
				end;
		end;
end.

#include<cstdio>
#include<cstring>// We need to use the strlen function in cstring
using namespace std;
char s[300000];
long h[300000],f[300000],nxt[300000],len[300000],queue[2][300000],head[2],foot[2];
int main()
{
	scanf("%s",&s);
	long cnt=0;
	head[0]=head[1]=foot[0]=foot[1]=0;// Initialize the queue
	for(long i=0,l=strlen(s);i<l;++i)
	{
		nxt[i]=-1;
		if(head['1'-s[i]]!=foot['1'-s[i]])// Use queue to find the suitable zebra sequence in a short time
		{
			long j=queue['1'-s[i]][head['1'-s[i]]++];
			f[j]=nxt[f[j]]=i;
			len[j]++;
			queue[s[i]-'0'][foot[s[i]-'0']++]=j;
			continue;
		}
		if(s[i]=='1')
		{
			printf("-1");
			return 0;
		}
		else
		{
			h[cnt]=f[cnt]=i;
			len[cnt]=1;
			queue[s[i]-'0'][foot[s[i]-'0']++]=cnt++;
		}
	}
	if(head[1]!=foot[1])// Check whether the queue of '1' is empty to check if there is a zebra sequence ended with '1'
	{
		printf("-1");
		return 0;
	}
	printf("%ld",cnt);
	for(long i=0;i<cnt;++i)
	{
		printf("\n%ld",len[i]);
		for(long j=h[i];j!=-1;j=nxt[j])
			printf(" %ld",j+1);
	}
	return 0;
}
