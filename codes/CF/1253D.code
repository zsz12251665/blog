var
	f:array[0..200000]of longint;
	n,m,i,x,y,p,ans:longint;
function find(p:longint):longint;
begin
	if f[p]<>p then
		f[p]:=find(f[p]);
	exit(f[p]);
end;
procedure merge(a,b:longint);
var
	fa,fb:longint;
begin
	fa:=find(a);
	fb:=find(b);
	if fa>fb then//Make sure the root point has the maximum index
		f[fb]:=fa
	else
		f[fa]:=fb;
end;
begin
	read(n,m);
	for i:=0 to n do
		f[i]:=i;
	for i:=1 to m do
		begin
			read(x,y);
			merge(x,y);
		end;
	ans:=0;
	p:=find(1);//p is the maximum index in this block
	for i:=1 to n do//Scan the sequence and add edges if necessary
		begin
			if find(i)<>p then//Find a point which does not match
				begin
					merge(i,p);
					p:=find(i);//Update the maximum index
					inc(ans);
				end;
			if (i=p) and (i<n) then//Jump to the next connected block
				p:=find(i+1);
		end;
	write(ans);
end.

#include<cstdio>
using namespace std;
long f[200001];
long find(long p)
{
	if(f[p]!=p)
		f[p]=find(f[p]);
	return f[p];
}
void merge(long a,long b)
{
	long fa=find(a),fb=find(b);
	if(fa>fb)//Make sure the root point has the maximum index
		f[fb]=fa;
	else
		f[fa]=fb;
}
int main()
{
	long n,m;
	scanf("%ld%ld",&n,&m);
	for(long i=0;i<=n;++i)
		f[i]=i;
	for(long i=0,x,y;i<m;++i)
	{
		scanf("%ld%ld",&x,&y);
		merge(x-1,y-1);
	}
	long ans=0;
	for(long i=0,p=find(0);i<n;++i)//Scan the sequence and add edges if necessary, p is the maximum index in this block
	{
		if(find(i)!=p)//Find a point which does not match
		{
			merge(i,p);
			p=find(i);//Update the maximum index
			++ans;
		}
		if(i==p && i<n-1)//Jump to the next connected block
			p=find(i+1);
	}
	printf("%ld",ans);
	return 0;
}
