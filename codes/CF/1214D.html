<h1>CF 1214D</h1>
<p><time>2019-09-05 23:57</time> by zsz12251665</p>
<section>
	<h2>Problem</h2>
	<ul class="buttonList">
		<a target="_blank" href="https://vjudge.net/problem/CodeForces-1214D"><li>Virtual Judge</li></a>
		<a target="_blank" href="https://codeforces.com/problemset/problem/1214/D"><li>Codeforces</li></a>
	</ul>
</section>
<section>
	<h2>Solution</h2>
	<p>It was really disappointing that I did not finish it during the contest because I was thinking about network flow until Wei Jiaxi provided me a hint. </p>
	<p>Firstly, we could find out all the cells that a valid path may passed with searching twice, of which one from <data value="o{(}c{1}o{,}c{1}o{)}"></data> and the other from <data value="o{(}v{n}o{,}v{m}o{)}"></data>. Of course no cell needs to be turn into forest if the treasure is already unreachable. And It is also obvious that at most we only need to turn two cells into forest, which are the ones beside the start or the end. But in which situation can we make it with a single cells turned? Here comes the hint: we find the path at the right top and the the one at the left bottom. They are the border of the part of valid cells. If they have any cell in common, we could turn this cell into forest to prevent Vasya from reaching the treasure. If there is no common cell, a single change will not be able to block Vasya. So the key is to find the possible answers and when each of them applies. </p>
</section>
<section>
	<h2>Code</h2>
	<section>
		<h3>Pascal</h3>
		<code lang="pas"></code>
	</section>
	<section>
		<h3>C++</h3>
		<code lang="cpp"></code>
	</section>
</section>
