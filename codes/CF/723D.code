var
	island:array[1..50,1..50]of integer;
	lakex,lakey,size:array[1..2500]of integer;
	lake,n,m,k,i,j,ans:integer;
	s:string;
procedure qsort(l,r:integer);//Sort the lakes according to their sizes
var
	x,y,std,tmp:integer;
begin
	x:=l;
	y:=r;
	std:=size[(l+r) div 2];
	while x<y do
		begin
			while size[x]<std do
				inc(x);
			while size[y]>std do
				dec(y);
			if x<=y then
				begin
					tmp:=size[x];//Exchange the lakes' information
					size[x]:=size[y];
					size[y]:=tmp;
					tmp:=lakex[x];
					lakex[x]:=lakex[y];
					lakex[y]:=tmp;
					tmp:=lakey[x];
					lakey[x]:=lakey[y];
					lakey[y]:=tmp;
					inc(x);
					dec(y);
				end;
		end;
	if l<y then
		qsort(l,y);
	if r>x then
		qsort(x,r);
end;
function search(x,y:integer):integer;//Search the whole district to get the size of the lake
var
	tmp:integer;
begin
	if (island[x+1][y]=-10000)or(island[x-1][y]=-10000)//If it is next to the sea, it is the sea too
	or(island[x][y+1]=-10000)or(island[x][y-1]=-10000) then
		exit(-10000);
	island[x,y]:=-2;//Mark the water that has been counted
	tmp:=1;
	if island[x+1,y]=0 then//Search the water around
		tmp+=search(x+1,y);
	if island[x-1,y]=0 then
		tmp+=search(x-1,y);
	if island[x,y+1]=0 then
		tmp+=search(x,y+1);
	if island[x,y-1]=0 then
		tmp+=search(x,y-1);
	if tmp<0 then//If it is connected to water which is next to the sea, it is the sea too
		exit(-10000);
	exit(tmp);
end;
procedure fill(x,y,mark,key:integer);//Fill the lake with the mark and the key is the mark which it used to be
begin
	island[x,y]:=mark;
	if island[x+1,y]=key then
		fill(x+1,y,mark,key);
	if island[x-1,y]=key then
		fill(x-1,y,mark,key);
	if island[x,y+1]=key then
		fill(x,y+1,mark,key);
	if island[x,y-1]=key then
		fill(x,y-1,mark,key);
end;
begin
	lake:=0;
	ans:=0;
	readln(n,m,k);
	for i:=1 to n do//Read the map of the island
		begin
			readln(s);
			for j:=1 to m do
				if s[j]='*' then//-1 means land, -10000 means sea, 0 means water
					island[i,j]:=-1
				else
					if (i=1)or(j=1)or(i=n)or(j=m) then
						island[i,j]:=-10000
					else
						island[i,j]:=0;
		end;
	for i:=1 to n do//Find all the lakes on the island
		for j:=1 to m do
			if island[i,j]=0 then
				begin
					fill(i,j,search(i,j),-2);
					if island[i,j]>0 then//Keep the lakes' information
						begin
							inc(lake);
							lakex[lake]:=i;
							lakey[lake]:=j;
							size[lake]:=island[i,j];
						end;
				end;
	qsort(1,lake);
	for i:=1 to lake-k do//Fill the smallest lakes with land
		begin
			ans:=ans+size[i];
			fill(lakex[i],lakey[i],-1,size[i]);
		end;
	writeln(ans);
	for i:=1 to n do
		begin
			for j:=1 to m do
				if island[i,j]=-1 then
					write('*')
				else
					write('.');
			writeln;
		end;
end.

#include<cstdio>
int island[50][50],lakex[2500],lakey[2500],size[2500],lake=0,n,m;
char s[51];
void qsort(int l,int r)//Sort the lakes according to their sizes
{
	int x=l,y=r,std=size[(l+r)/2];
	while(x<y)
	{
		while(size[x]<std)
			x++;
		while(size[y]>std)
			y--;
		if(x<=y)
		{
			int tmp=size[x];//Exchange the lakes' information
			size[x]=size[y];
			size[y]=tmp;
			tmp=lakex[x];
			lakex[x]=lakex[y];
			lakex[y]=tmp;
			tmp=lakey[x];
			lakey[x]=lakey[y];
			lakey[y]=tmp;
			x++;
			y--;
		}
	}
	if(l<y)
		qsort(l,y);
	if(r>x)
		qsort(x,r);
}
int search(int x,int y)//Search the whole district to get the size of the lake
{
	if((island[x+1][y]==-10000)||(island[x-1][y]==-10000)//If it is next to the sea, it is the sea too
	||(island[x][y+1]==-10000)||(island[x][y-1]==-10000))
		return -10000;
	island[x][y]=-2;//Mark the water that has been counted
	int tmp=1;
	if(island[x+1][y]==0)//Search the water around
		tmp+=search(x+1,y);
	if(island[x-1][y]==0)
		tmp+=search(x-1,y);
	if(island[x][y+1]==0)
		tmp+=search(x,y+1);
	if(island[x][y-1]==0)
		tmp+=search(x,y-1);
	if(tmp<0)//If it is connected to water which is next to the sea, it is the sea too
		return -10000;
	return tmp;
}
void fill(int x,int y,int mark,int key)//Fill the lake with the mark and the key is the mark which it used to be
{
	island[x][y]=mark;
	if(island[x+1][y]==key)
		fill(x+1,y,mark,key);
	if(island[x-1][y]==key)
		fill(x-1,y,mark,key);
	if(island[x][y+1]==key)
		fill(x,y+1,mark,key);
	if(island[x][y-1]==key)
		fill(x,y-1,mark,key);
}
int main()
{
	int k,ans=0;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=0;i<n;i++)//Read the map of the island
	{
		scanf("%s",&s);
		for(int j=0;j<m;j++)
			if(s[j]=='*')//-1 means land, -10000 means sea, 0 means water
				island[i][j]=-1;
			else
				if((i==0)||(j==0)||(i==n-1)||(j==m-1))
					island[i][j]=-10000;
				else
					island[i][j]=0;
	}
	for(int i=0;i<n;i++)//Find all the lakes on the island
		for(int j=0;j<m;j++)
			if(island[i][j]==0)
			{
				fill(i,j,search(i,j),-2);
				if(island[i][j]>0)//Keep the lakes' information
				{
					lakex[lake]=i;
					lakey[lake]=j;
					size[lake]=island[i][j];
					lake++;
				}
			}
	qsort(0,lake-1);
	for(int i=0;i<lake-k;i++)//Fill the smallest lakes with land
	{
		ans+=size[i];
		fill(lakex[i],lakey[i],-1,size[i]);
	}
	printf("%d\n",ans);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)
			if(island[i][j]==-1)
				putchar('*');
			else
				putchar('.');
		putchar('\n');
	}
	return 0;
}