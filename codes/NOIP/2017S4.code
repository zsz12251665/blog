var
	visit:array[1..1000]of boolean;//Remember to set up a visit array to prevent your dfs from falling into a loop
	x,y,z:array[1..1000]of int64;//To avoid overlimit or too many type conversions, I set the large integers as int64 directly
	h,r:int64;
	t,n,i,j:integer;
	getout:boolean;
function dfs(p:integer):boolean;
var
	i:integer;
begin
	visit[p]:=true;//Set the visit tag
	if z[p]>=h-r then//Check if the mouse has got out
		exit(true);
	for i:=1 to n do//Find the way to go on
		if not(visit[i])and((x[i]-x[p])*(x[i]-x[p])+(y[i]-y[p])*(y[i]-y[p])+(z[i]-z[p])*(z[i]-z[p])<=4*r*r) then
			if dfs(i) then
				exit(true);
	exit(false);
end;
begin
	read(t);
	while t>0 do
		begin
			read(n,h,r);
			for i:=1 to n do
				begin
					visit[i]:=false;
					read(x[i],y[i],z[i]);
				end;
			getout:=false;
			for i:=1 to n do//Enumerate the way to get in
				begin
					if z[i]<=r then
						getout:=dfs(i);
					if getout then
						break;
				end;
			if getout then
				writeln('Yes')
			else
				writeln('No');
			dec(t);
		end;
end.

#include<cstdio>
int n;
bool visit[1000];//Remember to set up a visit array to prevent your dfs from falling into a loop
long long x[1000],y[1000],z[1000],h,r;//To avoid overlimit or too many type conversions, I set the large integers as long long directly
bool dfs(int p)
{
	visit[p]=true;//Set the visit tag
	if(z[p]>=h-r)//Check if the mouse has got out
		return true;
	for(int i=0;i<n;i++)//Find the way to go on
		if((!visit[i])&&((x[i]-x[p])*(x[i]-x[p])+(y[i]-y[p])*(y[i]-y[p])+(z[i]-z[p])*(z[i]-z[p])<=4*r*r))
			if(dfs(i))
				return true;
	return false;
}
int main()
{
	int t;
	scanf("%d",&t);
	for(;t>0;t--)
	{
		scanf("%d%lld%lld",&n,&h,&r);
		for(int i=0;i<n;i++)
		{
			visit[i]=false;
			scanf("%lld%lld%lld",&x[i],&y[i],&z[i]);
		}
		bool getout=false;
		for(int i=0;(i<n)&&(getout==0);i++)//Enumerate the way to get in
			if(z[i]<=r)
				getout=dfs(i);
		printf(getout?"Yes\n":"No\n");
	}
	return 0;
}