<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>NOIp 2012S4 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body class="matrix">
		<h2 align="center">NOIp 2012S4</h2>
		<time>2017-10-31 11:57 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://www.luogu.org/problemnew/show/P1082">Luogu</a>
			<a target="_blank" href="https://www.vijos.org/p/1781">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem is completely a mathmatical problem that asked the number-theoretic reciprocal. We can calculate it with the extended Euclidean algorithm, which is also called <abbr title="the extended Greatest Common Division algorithm">exGCD</abbr>. </p>
			<p>exGCD is an algorithm which is able to find a pair of <var>(#x#,#y#)</var> that satisfies the B&eacute;zout's identity <var>#a##x#+#b##y#=gcd(#a#,#b#)</var>. Obviously, we have <var>#a##x#&equiv;1 (mod #b#) &hArr; #a##x#+#b##y#=1</var>. Because the problem promised that it must have an answer, so <var>gcd(#a#,#b#)=1</var>, or there will be no number-theoretic reciprocal for this pair of <var>(#a#,#b#)</var>. So the equation is a B&eacute;zout's identity. </p>
			<p>The standard Euclidean algorithm proceeds by a succession of Euclidean divisions whose quotients are not used, only the remainders are kept. However, for the extended algorithm, the successive quotients are used. We keep the quotients and put it back into the equation, we will have <var>#x#</var> and <var>#y#</var>. But attention! <var>#x#</var> and <var>#y#</var> may be negative numbers. So you need to change it into the minimum positive number, that is in <var>[1,#b#-1]</var>. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`a,b,x,y:longint;
				procedure exgcd(a,b:longint;var x,y:longint);
				begin
				`if b=0 then//The recursion border
				``begin
				```x:=1;//Keep the quotients
				```y:=0;
				```exit;
				``end;
				`exgcd(b,a mod b,y,x);//Recur gcd
				`y:=y-a div b*x;//Update the quotients
				end;
				begin
				`read(a,b);
				`exgcd(a,b,x,y);
				`write((x mod b+b) mod b);//Output the minimum positive integer
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				void exgcd(long a,long b,long &amp;x,long &amp;y)
				{
				`if(b==0)//The recursion border
				`{
				``x=1;//Keep the quotients
				``y=0;
				``return;
				`}
				`exgcd(b,a%b,y,x);//Recur gcd
				`y-=a/b*x;//Update the quotients
				}
				int main()
				{
				`long a,b,x,y;
				`scanf("%ld%ld",&amp;a,&amp;b);
				`exgcd(a,b,x,y);
				`printf("%ld",(x%b+b)%b);//Output the minimum positive integer
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
