<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>NOIp 2016S5 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body class="matrix">
		<h2 align="center">NOIp 2016S5</h2>
		<time>2017-09-22 21:54 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://www.luogu.org/problemnew/show/P2827">Luogu</a>
			<a target="_blank" href="https://www.vijos.org/p/2007">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>Most people used heap to solve the problem because it does seems like a problem of that kind. But when the mark came out, the heap didn't earn an <abbr title="Accepted">AC</abbr>. </p>
			<p>To my surprise, the problem requires 3 queues with an <var>O(#n#+#m#)</var> time complexity. The numbers in the queue are decreasing. That is beause the worm you choose to cut is always the longest among all. So the pieces is also getting shorter and shorter. You said that the length of the other worms are increasing every second? But the length of the pieces of worm are getting longer and longer as well. That makes the queues monotonic. So at first, put all the worms in the first queue and sort it. Then in every moment of <var>[1,#m#]</var>, choose the longest worm from the heads of the 3 queues, cut it into two pieces and put them into the second queue and the third queue. How about the increasing length? We can delay it. Only after getting the longest worm do we add the increased length of it. In order to keep it still suitable for the pieces, subtract the increased length from each piece after cutting. That can reduce the time complexity of each cutting operator into <var>O(1)</var>. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`queue:array[1..3,1..8000000]of longint;//Don't worry about the memory because you are given 512 MB in this problem
				`head,foot:array[1..3]of longint;
				`n,m,u,v,i:longint;
				`q,t,j,mx:integer;
				`worm:int64;
				procedure qsort(l,r:longint);
				var
				`x,y,tmp,std:longint;
				begin
				`x:=l;
				`y:=r;
				`std:=queue[1,(l+r) div 2];
				`while x&lt;y do
				``begin
				```while queue[1,x]&gt;std do
				````inc(x);
				```while queue[1,y]&lt;std do
				````dec(y);
				```if x&lt;=y then
				````begin
				`````tmp:=queue[1,x];
				`````queue[1,x]:=queue[1,y];
				`````queue[1,y]:=tmp;
				`````inc(x);
				`````dec(y);
				````end;
				``end;
				`if l&lt;y then
				``qsort(l,y);
				`if r&gt;x then
				``qsort(x,r);
				end;
				begin
				`read(n,m,q,u,v,t);
				`for i:=1 to n do
				``read(queue[1,i]);
				`qsort(1,n);
				`head[1]:=1;//Initialize the queues
				`head[2]:=1;
				`head[3]:=1;
				`foot[1]:=n;
				`foot[2]:=0;
				`foot[3]:=0;
				`for i:=1 to m do
				``begin
				```worm:=-maxlongint;//Find the longest worm
				```for j:=1 to 3 do
				````if (head[j]&lt;=foot[j])and(worm&lt;queue[j,head[j]]) then
				`````begin
				``````mx:=j;
				``````worm:=queue[j,head[j]];
				`````end;
				```inc(head[mx]);
				```worm:=worm+i*q-q;//Don't forget to add the length while not being cut
				```if i mod t=0 then
				````write(worm,' ');
				```inc(foot[2]);//Push the two pieces into the queue
				```inc(foot[3]);
				```queue[2,foot[2]]:=worm*u div v-i*q;
				```queue[3,foot[3]]:=worm-queue[2,foot[2]]-2*i*q;
				``end;
				`writeln;
				`for i:=1 to n+m do
				``begin
				```worm:=-maxlongint;//Find the longest worm
				```for j:=1 to 3 do
				````if (head[j]&lt;=foot[j])and(worm&lt;queue[j,head[j]]) then
				`````begin
				``````mx:=j;
				``````worm:=queue[j,head[j]];
				`````end;
				```inc(head[mx]);
				```worm:=worm+m*q;
				```if i mod t=0 then
				````write(worm,' ');
				``end;
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				long queue[3][8000000],foot[3],head[3];//Don't worry about the memory because you are given 512 MB in this problem
				void qsort(long l,long r)
				{
				`long x=l,y=r,std=queue[0][(l+r)/2];
				`while(x&lt;y)
				`{
				``while(queue[0][x]&gt;std)
				```x++;
				``while(queue[0][y]&lt;std)
				```y--;
				``if(x&lt;=y)
				``{
				```long tmp=queue[0][x];
				```queue[0][x++]=queue[0][y];
				```queue[0][y--]=tmp;
				``}
				`}
				`if(l&lt;y)
				``qsort(l,y);
				`if(x&lt;r)
				``qsort(x,r);
				}
				int main()
				{
				`long n,m,u,v;
				`int q,t;
				`scanf("%ld%ld%d%ld%ld%d",&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t);
				`for(long i=0;i&lt;n;i++)
				``scanf("%ld",&amp;queue[0][i]);
				`qsort(0,n-1);
				`head[0]=head[1]=head[2]=foot[1]=foot[2]=0;//Initialize the queues
				`foot[0]=n;
				`for(long i=0;i&lt;m;i++)
				`{
				``int mx;//Find the longest worm
				``long long worm=-2147483647;
				``for(int j=0;j&lt;3;j++)
				```if((head[j]&lt;foot[j])&amp;&amp;(queue[j][head[j]]&gt;worm))
				```{
				````mx=j;
				````worm=queue[j][head[j]];
				```}
				``worm+=i*q;//Don't forget to add the length while not being cut
				``if((i+1)%t==0)
				```printf("%lld ",worm);
				``queue[1][foot[1]]=worm*u/v-q*(i+1);//Push the two pieces into the queue
				``queue[2][foot[2]]=worm-queue[1][foot[1]]-2*q*(i+1);
				``head[mx]++;
				``foot[1]++;
				``foot[2]++;
				`}
				`putchar('\n');
				`for(long i=0;i&lt;n+m;i++)
				`{
				``int mx;//Find the longest worm
				``long long worm=-2147483647;
				``for(int j=0;j&lt;3;j++)
				```if((head[j]&lt;foot[j])&amp;&amp;(queue[j][head[j]]&gt;worm))
				```{
				````mx=j;
				````worm=queue[j][head[j]];
				```}
				``worm+=m*q;
				``if((i+1)%t==0)
				```printf("%lld ",worm);
				``head[mx]++;
				`}
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
