<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>NOIp 2014S5 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body class="matrix">
		<h2 align="center">NOIp 2014S5</h2>
		<time>2017-11-09 20:46 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://www.luogu.org/problemnew/show/P2296">Luogu</a>
			<a target="_blank" href="https://www.vijos.org/p/1909">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem is a shortest path problem. We can solved it with Dijkstra's algorithm, Bellman-Ford algorithm or <abbr title="Shortest Path Faster Algorithm">SPFA</abbr>. My solution uses SPFA, an improvement of the Bellman-Ford algorithm, but in the solution I won't talk much about it. We'll focus on the requirement of the path. </p>
			<p>The problem asks us to find a path that is formed by the points that have no point not linked to the destination connected. So we can use a <abbr title="Depth-First Search">DFS</abbr> to find out all the points that is linked to the destination with the graph reversed. Then we can mark the points which are not allowed to be part of the path. Then we can run the SPFA. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`h_nxt,f_nxt:array[1..200000]of longint;//the h arrays are the edges in the normal order, the f ones are the edges in the reverse order
				`h,f:array[1..10000]of longint;
				`h_des,f_des:array[1..200000]of integer;
				`dis,status,queue:array[1..10000]of integer;
				`inqueue:array[1..10000]of boolean;
				`m,j:longint;
				`n,s,t,i,p,head,foot:integer;
				procedure mark(p:integer);//Mark the points that are linked to the destination
				var
				`i:longint;
				begin
				`i:=f[p];
				`while i&lt;&gt;-1 do
				``begin
				```if status[f_des[i]]=0 then
				````begin
				`````status[f_des[i]]:=1;
				`````mark(f_des[i]);
				````end;
				```i:=f_nxt[i];
				``end;
				end;
				begin
				`read(n,m);
				`for i:=1 to n do//Initialize the arrays
				``begin
				```h[i]:=-1;//The sign of the end
				```f[i]:=-1;
				```status[i]:=0;//status[i]==1 means i is linked to t, status[i]==0 means it isn't, and status[i]>=10 means there is at least 1 point which is connected to i but not linked to t
				```dis[i]:=maxint;
				```inqueue[i]:=false;
				``end;
				`for j:=1 to m do
				``begin
				```read(f_des[j],h_des[j]);
				```h_nxt[j]:=h[f_des[j]];//Insert the edges
				```f_nxt[j]:=f[h_des[j]];
				```h[f_des[j]]:=j;
				```f[h_des[j]]:=j;
				``end;
				`read(s,t);
				`status[t]:=1;
				`mark(t);
				`for i:=1 to n do//Mark the points that is connect to the points which are not linked to the destination
				``begin
				```j:=h[i];
				```while j&lt;&gt;-1 do
				````begin
				`````if status[h_des[j]] mod 10&lt;&gt;1 then
				``````begin
				```````status[i]:=status[i]+10;
				```````break;
				``````end;
				`````j:=h_nxt[j];
				````end;
				``end;
				`dis[s]:=0;//Use SPFA to find the shortest path
				`queue[1]:=s;
				`inqueue[s]:=true;
				`head:=1;
				`foot:=2;
				`while head&lt;&gt;foot do
				``begin
				```p:=queue[head];
				```head:=head mod 10000+1;
				```inqueue[p]:=false;
				```j:=h[p];
				```while j&lt;&gt;-1 do
				````begin
				`````if (status[h_des[j]]=1)and(dis[h_des[j]]&gt;dis[p]+1) then//Check if this point is optional
				``````begin
				```````if not(inqueue[h_des[j]]) then
				````````begin
				`````````inqueue[h_des[j]]:=true;
				`````````queue[foot]:=h_des[j];
				`````````foot:=foot mod 10000+1;
				````````end;
				```````dis[h_des[j]]:=dis[p]+1;
				``````end;
				`````j:=h_nxt[j];
				````end;
				``end;
				`if dis[t]=maxint then
				``write(-1)
				`else
				``write(dis[t]);
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				long h_nxt[200000],f_nxt[200000],h[10000],f[10000];//the h arrays are the edges in the normal order, the f ones are the edges in the reverse order
				int h_des[200000],f_des[200000],dis[10000],status[10000],inqueue[10000],queue[10000];
				void mark(int p)//Mark the points that are linked to the destination
				{
				`for(long i=f[p];i!=-1;i=f_nxt[i])
				``if(status[f_des[i]]==0)
				``{
				```status[f_des[i]]=1;
				```mark(f_des[i]);
				``}
				}
				int main()
				{
				`int n,s,t;
				`long m;
				`scanf("%d%ld",&amp;n,&amp;m);
				`for(int i=0;i&lt;n;i++)//Initialize the arrays
				`{
				``h[i]=f[i]=-1;//The sign of the end
				``status[i]=0;//status[i]==1 means i is linked to t, status[i]==0 means it isn't, and status[i]>=10 means there is at least 1 point which is connected to i but not linked to t
				``dis[i]=32767;
				``inqueue[i]=0;
				`}
				`for(long j=0;j&lt;m;j++)
				`{
				``scanf("%d%d",&amp;f_des[j],&amp;h_des[j]);
				``f_des[j]--;//C++ starts the arrays from 0 to n-1, so we minus 1 to make it suitable
				``h_des[j]--;
				``h_nxt[j]=h[f_des[j]];//Insert the edges
				``f_nxt[j]=f[h_des[j]];
				``h[f_des[j]]=j;
				``f[h_des[j]]=j;
				`}
				`scanf("%d%d",&amp;s,&amp;t);
				`s--;
				`t--;
				`status[t]=1;
				`mark(t);
				`for(int i=0;i&lt;n;i++)//Mark the points that is connect to the points which are not linked to the destination
				``for(long j=h[i];j!=-1;j=h_nxt[j])
				```if(status[h_des[j]]%10!=1)
				```{
				````status[i]+=10;
				````break;
				```}
				`dis[s]=0;//Use SPFA to find the shortest path
				`queue[0]=s;
				`inqueue[s]=1;
				`int head=0,foot=1;
				`while(head!=foot)
				`{
				``int p=queue[head];
				``head=(head+1)%10000;
				``inqueue[p]=0;
				``for(long j=h[p];j!=-1;j=h_nxt[j])
				```if((status[h_des[j]]==1)&amp;&amp;(dis[h_des[j]]&gt;dis[p]+1))//Check if this point is optional
				```{
				````if(inqueue[h_des[j]]==0)
				````{
				`````inqueue[h_des[j]]=1;
				`````queue[foot]=h_des[j];
				`````foot=(foot+1)%10000;
				````}
				````dis[h_des[j]]=dis[p]+1;
				```}
				`}
				`if(dis[t]==32767)
				``printf("-1");
				`else
				``printf("%d",dis[t]);
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
