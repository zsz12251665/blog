<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>NOIp 2014S2 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body class="matrix">
		<h2 align="center">NOIp 2014S2</h2>
		<time>2017-11-08 19:14 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://www.luogu.org/problemnew/show/P1351">Luogu</a>
			<a target="_blank" href="https://www.vijos.org/p/1906">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>I suppose that this is a mathmatical problem. Some people said in can also be solved with <abbr title="dynamic planning">dp</abbr> algorithm. But here I will just show the mathmatical solution. </p>
			<p>From the defination, we know that the points which made up of a united weight should be next to a common point. So we can enumerate every point and the points besides them to make the united weight. However, this solution is absolutely unacceptable because the time complexity will be about <var>O(#n#(^2^))</var> or close to <var>O(#n#(^3^))</var> when there are two layers of loops while enumerating the common point. </p>
			<p>Then I think of another way. For a set of <var>{#a#(_1_),#a#(_2_),#a#(_3_), ... ,#a#(_#n#_)}</var>, the sum of the product of every pair of <var>(#a#(_#i#_),#a#(_#j#_))</var> equals <var>(&sum;(_#k#&isin;[1,#n#]_)(#a#(_#k#_)))(^2^)</var>. This includes some situations look like <var>#a#(_#i#_)(^2^)</var>, so we can remove it by subtracting <var>&sum;(_#k#&isin;[1,#n#]_)(#a#(_#k#_)(^2^))</var>. That means while calculating the sum of all the united weights, we only need to enumerate the points beside the common point once. At the same time, we can find the maximum united weight by finding the maximum two weights. That means we can enumerate the common points with an <var>O(#d#(_#i#_))</var> process for each points, with which <var>#d#(_#i#_)</var> means the degree of the point <var>#i#</var>. So the total time complexity will be <var>O(#n#)</var> because there are <var>(#n#-1)</var> edges so the total degree will be <var>2(#n#-1)</var>. </p>
			<p>P. S. In fact, you don't need to divide 2 when collecting the sum of the united weights. Becuase when you collect the united weight of the points pair <var>(#u#,#v#)</var>, you collect <var>(#v#,#u#)</var> at the same time by multiply the united weight with 2. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`des,nxt:array[1..400000]of longint;
				`h:array[1..200000]of longint;
				`w:array[1..200000]of integer;
				`n,i,j,u,v,sum,max:longint;//sum is the sum of the united weights, max is the maximum united weight
				`first,second,linear,square:integer;//first keeps the first biggest weight and second keeps the second one
				begin
				`read(n);
				`for i:=1 to n do//Initialize the adjacency table
				``h[i]:=-1;
				`for i:=1 to n-1 do
				``begin
				```read(u,v);
				```des[2*i-1]:=v;//Put both sides of the edge into adjacency table
				```des[2*i]:=u;
				```nxt[2*i-1]:=h[u];
				```nxt[2*i]:=h[v];
				```h[u]:=2*i-1;
				```h[v]:=2*i;
				``end;
				`for i:=1 to n do
				``read(w[i]);
				`sum:=0;
				`max:=0;
				`for i:=1 to n do
				``begin
				```linear:=0;
				```square:=0;
				```first:=-1;
				```second:=-1;
				```j:=h[i];
				```while j&lt;&gt;-1 do
				````begin
				`````if first&lt;w[des[j]] then//Update the maximum two numbers
				``````begin
				```````second:=first;
				```````first:=w[des[j]];
				``````end
				`````else
				``````if second&lt;w[des[j]] then
				```````second:=w[des[j]];
				`````linear:=(linear+w[des[j]]) mod 10007;//Update the linear sum
				`````square:=(square+w[des[j]]*w[des[j]]) mod 10007;//Update the square sum
				`````j:=nxt[j];
				````end;
				```if first*second&gt;max then
				````max:=first*second;
				```sum:=(sum+linear*linear-square) mod 10007;//Adding the sum
				``end;
				`write(max,' ',sum);
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				long des[400000],nxt[400000],h[200000];
				int w[200000];
				int main()
				{
				`long n;
				`scanf("%ld",&amp;n);
				`for(long i=0;i&lt;n;i++)//Initialize the adjacency table
				``h[i]=-1;
				`for(long i=1,u,v;i&lt;n;i++)
				`{
				``scanf("%ld%ld",&amp;u,&amp;v);
				``des[2*i-2]=v-1;//Put both sides of the edge into adjacency table
				``des[2*i-1]=u-1;
				``nxt[2*i-2]=h[u-1];
				``nxt[2*i-1]=h[v-1];
				``h[u-1]=2*i-2;
				``h[v-1]=2*i-1;
				`}
				`for(long i=0;i&lt;n;i++)
				``scanf("%d",&amp;w[i]);
				`long sum=0,max=0;//sum is the sum of the united weights, max is the maximum united weight
				`for(long i=0;i&lt;n;i++)
				`{
				``int linear=0,square=0,first=-1,second=-1;//first keeps the first biggest weight and second keeps the second one
				``for(long j=h[i];j!=-1;j=nxt[j])
				``{
				```if(first&lt;w[des[j]])//Update the maximum two numbers
				```{
				````second=first;
				````first=w[des[j]];
				```}
				```else
				````if(second&lt;w[des[j]])
				`````second=w[des[j]];
				```linear=(linear+w[des[j]])%10007;//Update the linear sum
				```square=(square+w[des[j]]*w[des[j]])%10007;//Update the square sum
				``}
				``if(first*second&gt;max)
				```max=first*second;
				``sum=(sum+linear*linear-square)%10007;
				`}
				`printf("%ld %ld",max,sum);//Adding the sum
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
