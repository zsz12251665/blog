<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
		<link rel="shortcut icon" href="/blog.png"/>
		<title>NOIp 2014 TGT2 - zsz12251665's Blog</title>
		<link rel="stylesheet" type="text/css" href="/codes/style.css"/>
		<base target="_parent"/>
	</head>
	<body>
		<h2 align="center">NOIp 2014 TGT2</h2>
		<time>2017-11-08 19:14 by zsz12251665</time>
		<h3>Problem</h3>
		<section>
			<a target="_blank" href="https://www.luogu.org/problem/show?pid=1351">Luogu</a>
			<br/>
			<a target="_blank" href="https://www.vijos.org/p/1906">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>I suppose that this is a mathmatical problem. Some people said in can also be solved with <abbr title="dynamic planning">dp</abbr> algorithm. But here I will just show the mathmatical solution. </p>
			<p>From the defination, we know that the points which made up of a united weight should be next to a common point. So we can enumerate every point and the points besides them to make the united weight. However, this solution is absolutely unacceptable because the time complexity will be about O(<var>n</var><sup>2</sup>) or close to O(<var>n</var><sup>3</sup>) when there are two layers of loops while enumerating the common point. </p>
			<p>Then I think of another way. For a set of {<var>a<sub>1</sub></var>,<var>a<sub>2</sub></var>,<var>a<sub>3</sub></var>, ... ,<var>a<sub>n</sub></var> }, the sum of the product of every pair of (<var>a<sub>i</sub></var>,<var>a<sub>j</sub></var>) equals half of the square of the linear sum of all elements in the set minus half of the square sum of all elements in the set. That means while calculating the sum of all the united weights, we only need to enumerate the points beside the common point once. At the same time, we can find the maximum united weight by finding the maximum two weights. That means we can enumerate the common points with a O(<var>d<sub>i</sub></var>) process for each points, with which <var>d<sub>i</sub></var> means the degree of the point <var>i</var>. So the total time complexity will be O(<var>n</var>) because there are (<var>n</var>-1) edges so the total degree will be 2(<var>n</var>-1). </p>
			<p>P. S. In fact, you don't need to devide 2 when collecting the sum of the united weights. Becuase when you collect the united weight of the points pair (<var>u</var>,<var>v</var>), you should collect (<var>v</var>,<var>u</var>) at the same time by multiply the united weight with 2. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;des,nxt:array[1..400000]of longint;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;h:array[1..200000]of longint;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;w:array[1..200000]of integer;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;n,i,j,u,v,sum,max:longint;<strong>//sum is the sum of the united weights, max is the maximum united weight</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;first,second,linear,square:integer;<strong>//first keeps the first biggest weight and second keeps the second one</strong><br/>
				begin<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;read(n);<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for i:=1 to n do<strong>//Format the adjacency table</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[i]:=-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for i:=1 to n-1 do<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(u,v);<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;des[2*i-1]:=v;<strong>//Put both sides of the edge into adjacency table</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;des[2*i]:=u;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt[2*i-1]:=h[u];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt[2*i]:=h[v];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[u]:=2*i-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[v]:=2*i;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for i:=1 to n do<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(w[i]);<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;sum:=0;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;max:=0;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for i:=1 to n do<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linear:=0;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square:=0;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first:=-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second:=-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j:=h[i];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while j&lt;&gt;-1 do<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if first&lt;w[des[j]] then<strong>//Update the maximum two numbers</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second:=first;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first:=w[des[j]];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if second&lt;w[des[j]] then<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second:=w[des[j]];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linear:=(linear+w[des[j]]) mod 10007;<strong>//Update the linear sum</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square:=(square+w[des[j]]*w[des[j]]) mod 10007;<strong>//Update the square sum</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j:=nxt[j];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if first*second&gt;max then<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max:=first*second;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:=(sum+linear*linear-square) mod 10007;<strong>//Adding the sum</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;write(max,' ',sum);<br/>
				end.<br/>
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;<br/>
				long des[400000],nxt[400000],h[200000];<br/>
				int w[200000];<br/>
				int main()<br/>
				{<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;long n;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;scanf("%ld",&amp;n);<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for(long i=0;i&lt;n;i++)<strong>//Format the adjacency table</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[i]=-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for(long i=1,u,v;i&lt;n;i++)<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanf("%ld%ld",&amp;u,&amp;v);<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;des[2*i-2]=v-1;<strong>//Put both sides of the edge into adjacency table</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;des[2*i-1]=u-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt[2*i-2]=h[u-1];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nxt[2*i-1]=h[v-1];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[u-1]=2*i-2;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[v-1]=2*i-1;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for(long i=0;i&lt;n;i++)<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanf("%d",&amp;w[i]);<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;long sum=0,max=0;<strong>//sum is the sum of the united weights, max is the maximum united weight</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;for(long i=0;i&lt;n;i++)<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int linear=0,square=0,first=-1,second=-1;<strong>//first keeps the first biggest weight and second keeps the second one</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(long j=h[i];j!=-1;j=nxt[j])<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(first&lt;w[des[j]])<strong>//Update the maximum two numbers</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second=first;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first=w[des[j]];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(second&lt;w[des[j]])<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second=w[des[j]];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linear=(linear+w[des[j]])%10007;<strong>//Update the linear sum</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square=(square+w[des[j]]*w[des[j]])%10007;<strong>//Update the square sum</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(first*second&gt;max)<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max=first*second;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum=(sum+linear*linear-square)%10007;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;printf("%ld %ld",max,sum);<strong>//Adding the sum</strong><br/>
				&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
				}<br/>
			</code>
		</section>
		<script type="text/javascript" src="/script.js"></script>
	</body>
</html>
