<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>POJ 3295 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body class="matrix">
		<h2 align="center">POJ 3295</h2>
		<time>2017-05-06 10:14 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/POJ-3295">vjudge</a>
			<a target="_blank" href="http://poj.org/problem?id=3295">POJ</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>Since there are many different groups of <var>(#p#,#q#,#r#,#s#,#t#)</var>. We need to enumerate them one by one. Luckily, all of them are 0 or 1, so there are just 32 groups. I got confused on how to know the expression. Later, I found that it is a prefix expression. So I can scan it from end to start and solve it like the suffix expression. You'll need a stack to keep the number you've get. When you get a number, put it into the stack. When you get an operator, push the top numbers, and put the answer into the stack. In this way, the last number left in the stack would be the answer of the whole expression. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`stack:array[1..100]of integer;
				`wff:string;
				procedure solve;
				var
				`p,q,r,s,t,top,i:integer;
				begin
				`for p:=0 to 1 do//Enumerate every possible group of (p,q,r,s,t)
				``for q:=0 to 1 do
				```for r:=0 to 1 do 
				````for s:=0 to 1 do
				`````for t:=0 to 1 do
				``````begin
				```````top:=1;
				```````for i:=length(wff) downto 1 do//Do not forget to scan from end to start since it's a prefix expression
				````````case wff[i] of
				`````````'p':
				``````````begin
				```````````stack[top]:=p;//Add number into the stack
				```````````inc(top);
				``````````end;
				`````````'q':
				``````````begin
				```````````stack[top]:=q;
				```````````inc(top);
				``````````end;
				`````````'r':
				``````````begin
				```````````stack[top]:=r;
				```````````inc(top);
				``````````end;
				`````````'s':
				``````````begin
				```````````stack[top]:=s;
				```````````inc(top);
				``````````end;
				`````````'t':
				``````````begin
				```````````stack[top]:=t;
				```````````inc(top);
				``````````end;
				`````````'K':
				``````````begin
				```````````dec(top);
				```````````stack[top-1]:=stack[top]*stack[top-1];//Calculate the answer and add it back to the stack
				``````````end;
				`````````'A':
				``````````begin
				```````````dec(top);
				```````````stack[top-1]:=1-(1-stack[top])*(1-stack[top-1]);
				``````````end;
				`````````'N':
				``````````stack[top-1]:=1-stack[top-1];
				`````````'C':
				``````````begin
				```````````dec(top);
				```````````if (stack[top]=1)and(stack[top-1]=0) then
				````````````stack[top-1]:=0
				```````````else
				````````````stack[top-1]:=1;
				``````````end;
				`````````'E':
				``````````begin
				```````````dec(top);
				```````````if stack[top]=stack[top-1] then
				````````````stack[top-1]:=1
				```````````else
				````````````stack[top-1]:=0;
				``````````end;
				````````end;
				```````if stack[top-1]=0 then
				````````begin
				`````````writeln('not');
				`````````exit;
				````````end;
				``````end;
				`writeln('tautology');
				end;
				begin
				`readln(wff);
				`while wff&lt;&gt;'0' do
				``begin
				```solve;//There are over 5 loops, so an exit in another function can simplify the code
				```readln(wff);
				``end;
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				#include&lt;cstring&gt;//We need to use the strlen function in cstring
				int stack[100];
				char wff[100];
				void solve()
				{
				`for(int p=0;p&lt;2;p++)//Enumerate every possible group of (p,q,r,s,t)
				``for(int q=0;q&lt;2;q++)
				```for(int r=0;r&lt;2;r++)
				````for(int s=0;s&lt;2;s++)
				`````for(int t=0;t&lt;2;t++)
				`````{
				``````int top=0;
				``````for(int i=strlen(wff)-1;i&gt;=0;i--)//Do not forget to scan from end to start since it's a prefix expression
				```````switch(wff[i])
				```````{
				````````case 'p':
				`````````stack[top]=p;//Add number into the stack
				`````````top++;
				`````````break;
				````````case 'q':
				`````````stack[top]=q;
				`````````top++;
				`````````break;
				````````case 'r':
				`````````stack[top]=r;
				`````````top++;
				`````````break;
				````````case 's':
				`````````stack[top]=s;
				`````````top++;
				`````````break;
				````````case 't':
				`````````stack[top]=t;
				`````````top++;
				`````````break;
				````````case 'K':
				`````````top--;
				`````````stack[top-1]=stack[top]*stack[top-1];//Calculate the answer and add it back to the stack
				`````````break;
				````````case 'A':
				`````````top--;
				`````````stack[top-1]=1-(1-stack[top])*(1-stack[top-1]);
				`````````break;
				````````case 'N':
				`````````stack[top-1]=1-stack[top-1];
				`````````break;
				````````case 'C':
				`````````top--;
				`````````if((stack[top]==1)&amp;&amp;(stack[top-1]==0))
				``````````stack[top-1]=0;
				`````````else
				``````````stack[top-1]=1;
				`````````break;
				````````case 'E':
				`````````top--;
				`````````if(stack[top]==stack[top-1])
				``````````stack[top-1]=1;
				`````````else
				``````````stack[top-1]=0;
				`````````break;
				```````}
				``````if(stack[top-1]==0)
				``````{
				```````printf("not\n");
				```````return;
				``````}
				`````}
				`printf("tautology\n");
				}
				int main()
				{
				`scanf("%s",&amp;wff);
				`while(wff[0]!='0')
				`{
				``solve();//There are over 5 loops, so a return in another function can simplify the code
				``scanf("%s",&amp;wff);
				`}
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
