var
	stack:array[1..100]of integer;
	wff:string;
procedure solve;
var
	p,q,r,s,t,top,i:integer;
begin
	for p:=0 to 1 do// Enumerate every possible group of (p,q,r,s,t)
		for q:=0 to 1 do
			for r:=0 to 1 do
				for s:=0 to 1 do
					for t:=0 to 1 do
						begin
							top:=1;
							for i:=length(wff) downto 1 do// Do not forget to scan from end to start since it's a prefix expression
								case wff[i] of
									'p':
										begin
											stack[top]:=p;// Add number into the stack
											inc(top);
										end;
									'q':
										begin
											stack[top]:=q;
											inc(top);
										end;
									'r':
										begin
											stack[top]:=r;
											inc(top);
										end;
									's':
										begin
											stack[top]:=s;
											inc(top);
										end;
									't':
										begin
											stack[top]:=t;
											inc(top);
										end;
									'K':
										begin
											dec(top);
											stack[top-1]:=stack[top]*stack[top-1];// Calculate the answer and add it back to the stack
										end;
									'A':
										begin
											dec(top);
											stack[top-1]:=1-(1-stack[top])*(1-stack[top-1]);
										end;
									'N':
										stack[top-1]:=1-stack[top-1];
									'C':
										begin
											dec(top);
											if (stack[top]=1) and (stack[top-1]=0) then
												stack[top-1]:=0
											else
												stack[top-1]:=1;
										end;
									'E':
										begin
											dec(top);
											if stack[top]=stack[top-1] then
												stack[top-1]:=1
											else
												stack[top-1]:=0;
										end;
								end;
							if stack[top-1]=0 then
								begin
									writeln('not');
									exit;
								end;
						end;
	writeln('tautology');
end;
begin
	readln(wff);
	while wff<>'0' do
		begin
			solve;// There are over 5 loops, so an exit in another function can simplify the code
			readln(wff);
		end;
end.

#include<cstdio>
#include<cstring>// We need to use the strlen function in cstring
using namespace std;
int stack[100];
char wff[100];
void solve()
{
	for(int p=0;p<2;++p)// Enumerate every possible group of (p,q,r,s,t)
		for(int q=0;q<2;++q)
			for(int r=0;r<2;++r)
				for(int s=0;s<2;++s)
					for(int t=0;t<2;++t)
					{
						int top=0;
						for(int i=strlen(wff)-1;i>=0;--i)// Do not forget to scan from end to start since it's a prefix expression
							switch(wff[i])
							{
								case 'p':
									stack[top]=p;// Add number into the stack
									++top;
									break;
								case 'q':
									stack[top]=q;
									++top;
									break;
								case 'r':
									stack[top]=r;
									++top;
									break;
								case 's':
									stack[top]=s;
									++top;
									break;
								case 't':
									stack[top]=t;
									++top;
									break;
								case 'K':
									--top;
									stack[top-1]=stack[top]*stack[top-1];// Calculate the answer and add it back to the stack
									break;
								case 'A':
									--top;
									stack[top-1]=1-(1-stack[top])*(1-stack[top-1]);
									break;
								case 'N':
									stack[top-1]=1-stack[top-1];
									break;
								case 'C':
									--top;
									stack[top-1]=(stack[top]==1 && stack[top-1]==0)?0:1;
									break;
								case 'E':
									--top;
									stack[top-1]=(stack[top]==stack[top-1])?1:0;
									break;
							}
						if(stack[top-1]==0)
						{
							printf("not\n");
							return;
						}
					}
	printf("tautology\n");
}
int main()
{
	scanf("%s",&wff);
	while(wff[0]!='0')
	{
		solve();// There are over 5 loops, so a return in another function can simplify the code
		scanf("%s",&wff);
	}
	return 0;
}
