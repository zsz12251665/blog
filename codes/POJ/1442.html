<h2 align="center">POJ 1442</h2>
<time>2018-01-08 22:03 by zsz12251665</time>
<h3>Problem</h3>
<section class="btnfield">
	<a target="_blank" href="https://vjudge.net/problem/POJ-1442">vjudge</a>
	<a target="_blank" href="http://poj.org/problem?id=1442">POJ</a>
</section>
<h3>Solution</h3>
<section>
	<p>Well, this problem requires two heaps. One is the small-root heap and the other one is the big-root heap. Then we do it like this: When we have processed <math>v{j}</math> GET requests, we keep the smallest <math>v{j}</math> integers in the big-root array. When an ADD request is taken, we could know whether the new integer is one of the smallest <math>v{j}</math> integers by comparing the root of the heap and the new element. If it is, replace the root with the new element and put the old root into the small-root heap. Otherwise, just put the new element into the small-root heap. So the <math>o{(}v{j}o{+}c{1}o{)}</math>-th smallest element will be the root of the small-root heap. So we can process an ADD request within <math>o{O}o{(}o{lg}v{n}o{)}</math>. When a GET request is taken, all we need to do is moving the root of the small-root heap into the big-root heap. This can be finished in <math>o{O}o{(}o{lg}v{n}o{)}</math> too. So the total time complexity is <math>o{O}o{(}o{lg}v{n}o{)}</math>. </p>
	<p>At the same time, this solution is also going to tell you that how to make a heap. The heap is a complete binary tree structure which all nodes except the roots is smaller(or bigger) than its father. That's why we have the small-root heap and the big-root heap. If the nodes are smaller than their fathers, the root will be the smallest of all. That is called small-root heap. Similarly, we have the big-root heap. In the following we use the small-root heap as an example. When a new element is added to the heap, put it at the end of the tree and compare it with his father. If the father isn't so small as the child, swap them and continue comparing. Otherwise, stopped and quit. There are <math>o{&lceil;}o{log}b{2}v{n}o{&rceil;}</math> levels in the heap, so the add request is <math>o{O}o{(}o{lg}v{n}o{)}</math>. When we need to pop the root out of the heap, we can replace it with the last element of the heap. Then we compare with its smallest child and if the father is bigger, swap them, or stopped and quit. So the time complexity of the pop request is also related to the number of the levels. So the pop request is <math>o{O}o{(}o{lg}v{n}o{)}</math> too. So with a heap, you can add or pop an element with a <math>o{O}o{(}o{lg}v{n}o{)}</math> time complexity and get the smallest element with a <math>o{O}o{(}c{1}o{)}</math> time complexity. </p>
</section>
<h3>Code</h3>
<section>
	<p>Pascal</p>
	<code></code>
	<p>C++</p>
	<code></code>
</section>
