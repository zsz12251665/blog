<h2>POJ 2388</h2>
<time>2018-01-05 21:20 by zsz12251665</time>
<h3>Problem</h3>
<section class="buttonField">
	<a target="_blank" href="https://vjudge.net/problem/POJ-2388">vjudge</a>
	<a target="_blank" href="http://poj.org/problem?id=2388">POJ</a>
</section>
<h3>Solution</h3>
<section>
	<p>This problem is solved by sorting the array<data value="v{milk}"></data> and out put the middle one. So in the Code I show you some popular sorting methods. </p>
	<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('insertion').offsetLeft,document.getElementById('insertion').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Insertion sort</a>: This is an <data value="o{O}o{(}v{n}p{2}o{)}"></data> algorithm. It sorts the array like sorting poker cards. You pick up one card, then put it at the right place in your hand. Both Insertion sort and Bubble sort is simple, but not efficent. </p>
	<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('bubble').offsetLeft,document.getElementById('bubble').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Bubble sort</a>: This is an <data value="o{O}o{(}v{n}p{2}o{)}"></data> algorithm too. You need to scan <data value="v{n}"></data> times of your array according to the algorithm. Every time you scan it, you find the biggest element and put it at the end, just like the big bubbles come up at first. </p>
	<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('quick').offsetLeft,document.getElementById('quick').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Quick sort</a>: This is an <data value="o{O}o{(}v{n}o{}o{lg}v{n}o{)}"></data> algorithm. It is efficient, but in the worst case, it makes <data value="o{O}o{(}v{n}p{2}o{)}"></data> comparisons, though this behavior is rare. Quick sort is a divide and conquer algorithm. Firstly, you divide the array into two smaller sub-arrays: the low elements and the high elements. Then you recursively sort the sub-arrays until the sizes of the sub-arrays are 0 or 1. </p>
	<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('merge').offsetLeft,document.getElementById('merge').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Merge sort</a>: This is an <data value="o{O}o{(}v{n}o{}o{lg}v{n}o{)}"></data> algorithm too. The main difference between Quick sort and Merge Sort is that Merge sort is stable in order and time while Quick sort is not. It is also a divide and conquer algorithm. You first divide the array into two sub-arrays, then sort them unless their sizes are 0 or 1 and lastly merge the two sub-arrays up by the smaller head element into the big array until all of them are put. </p>
	<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('heap').offsetLeft,document.getElementById('heap').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Heap sort</a>: As same as its name, Heap sort is a sorting algorithm with the data structure heap. As we all know that heap can add or pop an element in <data value="o{O}o{(}o{lg}v{n}o{)}"></data>, the time complexity of all is <data value="o{O}o{(}v{n}o{}o{lg}v{n}o{)}"></data>. </p>
	<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('counting').offsetLeft,document.getElementById('counting').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Counting sort</a>: Counting sort is an algorithm for sorting a collection of small integers. The time complexity is <data value="o{O}o{(}v{n}o{+}v{k}o{)}"></data> (<data value="v{k}"></data> is the data range). You need to set up another array <data value="v{counter}"></data>. Then you scan the data array to count the numbers of every integers in the data range with a time complexity of <data value="o{O}o{(}v{n}o{)}"></data>. In the end scan the array <data value="v{counter}"></data> and output the data. </p>
	<p>P. S. All codes given here are in increase order. </p>
</section>
<h3>Code</h3>
<section id="insertion">
	<p>Insertion sort Pascal</p>
	<code lang="pas"></code>
	<p>Insertion sort C++</p>
	<code lang="cpp"></code>
</section>
<section id="bubble">
	<p>Bubble sort Pascal</p>
	<code lang="pas"></code>
	<p>Bubble sort C++</p>
	<code lang="cpp"></code>
</section>
<section id="quick">
	<p>Quick sort Pascal</p>
	<code lang="pas"></code>
	<p>Quick sort C++</p>
	<code lang="cpp"></code>
</section>
<section id="merge">
	<p>Merge sort Pascal</p>
	<code lang="pas"></code>
	<p>Merge sort C++</p>
	<code lang="cpp"></code>
</section>
<section id="heap">
	<p>Heap sort Pascal</p>
	<code lang="pas"></code>
	<p>Heap sort C++</p>
	<code lang="cpp"></code>
</section>
<section id="counting">
	<p>Counting sort Pascal</p>
	<code lang="pas"></code>
	<p>Counting sort C++</p>
	<code lang="cpp"></code>
</section>
