<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>POJ 2388 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body class="matrix">
		<h2 align="center">POJ 2388</h2>
		<time>2018-01-05 21:20 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/POJ-2388">vjudge</a>
			<a target="_blank" href="http://poj.org/problem?id=2388">POJ</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem is solved by sorting the array<var>#milk#</var> and out put the middle one. So in the Code I show you some popular sorting methods. </p>
			<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('insertion').offsetLeft,document.getElementById('insertion').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Insertion sort</a>: This is an <var>O(#n#(^2^))</var> algorithm. It sorts the array like sorting poker cards. You pick up one card, then put it at the right place in your hand. Both Insertion sort and Bubble sort is simple, but not efficent. </p>
			<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('bubble').offsetLeft,document.getElementById('bubble').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Bubble sort</a>: This is an <var>O(#n#(^2^))</var> algorithm too. You need to scan <var>#n#</var> times of your array according to the algorithm. Every time you scan it, you find the biggest element and put it at the end, just like the big bubbles come up at first. </p>
			<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('quick').offsetLeft,document.getElementById('quick').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Quick sort</a>: This is an <var>O(#n#lg(#n#))</var> algorithm. It is efficent, but in the worst case, it makes <var>O(#n#(^2^))</var> comparisons, though this behavior is rare. Quick sort is a divide and conquer algorithm. Firstly, you divide the array into two smaller sub-arrays: the low elements and the high elements. Then you recursively sort the sub-arrays until the sizes of the sub-arrays are 0 or 1. </p>
			<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('merge').offsetLeft,document.getElementById('merge').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Merge sort</a>: This is an <var>O(#n#lg(#n#))</var> algorithm too. The main difference between Quick sort and Merge Sort is that Merge sort is stable in order and time while Quick sort is not. It is also a divide and conquer algorithm. You first divide the array into two sub-arrays, then sort them unless their sizes are 0 or 1 and lastly merge the two sub-arrays up by the smaller head element into the big array until all of them are put. </p>
			<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('heap').offsetLeft,document.getElementById('heap').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Heap sort</a>: As same as its name, Heap sort is a sorting algorithm with the data structure heap. As we all know that heap can add or pop an element in <var>O(lg(#n#))</var>, the time complexity of all is <var>O(#n#lg(#n#))</var>. </p>
			<p><a href="javascript:void(0);" onclick="window.scrollTo(document.getElementById('counting').offsetLeft,document.getElementById('counting').offsetTop-document.getElementsByTagName('header')[0].offsetHeight);">Counting sort</a>: Counting sort is an algorithm for sorting a collection of small integers. The time complexity is <var>O(#n#+#k#)</var>(<var>#k#</var> is the data range). You need to set up another array <var>#counter#</var>. Then you scan the data array to count the numbers of every integers in the data range with a time complexity of <var>O(#n#)</var>. In the end scan the array <var>#counter#</var> and output the data. </p>
			<p>P. S. All codes given here are in increase order. </p>
		</section>
		<h3>Code</h3>
		<section id="insertion">
			<p>Insertion sort Pascal Code</p>
			<code></code>
			<p>Insertion sort C++ Code</p>
			<code></code>
		</section>
		<section id="bubble">
			<p>Bubble sort Pascal Code</p>
			<code></code>
			<p>Bubble sort C++ Code</p>
			<code></code>
		</section>
		<section id="quick">
			<p>Quick sort Pascal Code</p>
			<code></code>
			<p>Quick sort C++ Code</p>
			<code></code>
		</section>
		<section id="merge">
			<p>Merge sort Pascal Code</p>
			<code></code>
			<p>Merge sort C++ Code</p>
			<code></code>
		</section>
		<section id="heap">
			<p>Heap sort Pascal Code</p>
			<code></code>
			<p>Heap sort C++ Code</p>
			<code></code>
		</section>
		<section id="counting">
			<p>Counting sort Pascal Code</p>
			<code></code>
			<p>Counting sort C++ Code</p>
			<code></code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
