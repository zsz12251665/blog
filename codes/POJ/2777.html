<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>POJ 2777 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="stylesheet" type="text/css" href="/codes/style.css" />
	</head>
	<body>
		<h2 align="center">POJ 2777</h2>
		<time>2017-11-24 21:39 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/POJ-2777">vjudge</a>
			<a target="_blank" href="http://poj.org/problem?id=2777">POJ</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This problem needs a segment tree to solve. A segment tree is used to solve problems based on ranges. For example, this problem requires us to provide two kinds of operation, which are setting values on a range and asking number of the colours on a range. </p>
			<p>The first step is to build and format the segment tree. As we all know, the segment tree is a tree of which the nodes keeps the information of the range <var>[#l#,#r#]</var> and its two children keep the information of the range <var>[#l#,/#l#+#r#/2/]</var> and <var>[/#l#+#r#/2/+1,#r#]</var>. So we can use a <abbr title="Depth-First Search">DFS</abbr> to format it. By the way, we will also need to use the state compression to keep the states of thirty colours in an integer. Then we can read the operations. For each setting operation, we can finish it in <var>O(lg(#n#))</var>. This is because when the operation come to a node, we can check if the range of the node is in the range of the operation. If it is, set the lazytag up and return, or pass down the lazytag, send the operation to its children and update colour state. For each asking operation, it can also be finished in <var>O(lg(#n#))</var>. It is similar to the setting operation but we just need to return the the compressed state and then count the number of colours. So the time complexity of the whole algorithm is <var>O(#n#lg(#n#))</var>. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`left,right,colour:array[1..262144]of longint;
				`lazytag:array[1..262144]of integer;
				`l,o,i,a,b,cset:longint;
				`t:integer;
				`s:char;
				procedure format(p,l,r:longint);//Build and format the segment tree
				begin
				`left[p]:=l;
				`right[p]:=r;
				`colour[p]:=1 shl 1;
				`lazytag[p]:=0;
				`if l=r then
				``exit;
				`format(2*p,l,(l+r) div 2);
				`format(2*p+1,(l+r) div 2+1,r);
				end;
				procedure change(p,l,r:longint;c:integer);//The setting operation
				var
				`mid:longint;
				begin
				`if (l=left[p])and(r=right[p]) then//If the range is covered, set the lazytag(that's why the operation is O(lg(n)))
				``begin
				```colour[p]:=1 shl c;
				```if l&lt;&gt;r then
				````lazytag[p]:=c;
				```exit;
				``end;
				`mid:=(left[p]+right[p]) div 2;
				`if lazytag[p]&lt;&gt;0 then//Pass down the lazytag
				``begin
				```change(2*p,left[p],mid,lazytag[p]);
				```change(2*p+1,mid+1,right[p],lazytag[p]);
				```lazytag[p]:=0;
				``end;
				`if r&lt;=mid then
				``change(2*p,l,r,c);
				`if l&gt;mid then
				``change(2*p+1,l,r,c);
				`if (l&lt;=mid)and(r&gt;mid) then
				``begin
				```change(2*p,l,mid,c);
				```change(2*p+1,mid+1,r,c);
				``end;
				`colour[p]:=(colour[2*p])or(colour[2*p+1]);//Update the colour state
				end;
				function search(p,l,r:longint):longint;//The asking operation
				var
				`mid:longint;
				begin
				`if (lazytag[p]&lt;&gt;0)or(l=left[p])and(r=right[p]) then//Lazytag exists means the range is in the same colour, so we don't need to search
				``exit(colour[p]);
				`mid:=(left[p]+right[p]) div 2;
				`if r&lt;=mid then
				``exit(search(2*p,l,r));
				`if l&gt;mid then
				``exit(search(2*p+1,l,r));
				`if (l&lt;=mid)and(r&gt;mid) then
				``exit((search(2*p,l,mid))or(search(2*p+1,mid+1,r)));
				end;
				begin
				`read(l,t,o);
				`format(1,1,l);//Build and format the segment tree
				`for i:=1 to o do
				``begin
				```read(s);
				```while (s&lt;&gt;'C')and(s&lt;&gt;'P') do
				````read(s);
				```if s='C' then//The setting operation
				````begin
				`````read(a,b,t);
				`````change(1,a,b,t);
				````end;
				```if s='P' then//The asking operation
				````begin
				`````read(a,b);
				`````cset:=search(1,a,b);
				`````t:=0;//Count the number of colours
				`````while cset&lt;&gt;0 do
				``````begin
				```````t:=t+cset mod 2;
				```````cset:=cset div 2;
				``````end;
				`````writeln(t);
				````end;
				``end;
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				long left[262144],right[262144],colour[262144];
				int lazytag[262144];
				void format(long p,long l,long r)//Build and format the segment tree
				{
				`left[p]=l;
				`right[p]=r;
				`colour[p]=1&lt;&lt;1;
				`lazytag[p]=0;
				`if(l==r)
				``return;
				`format(2*p+1,l,(l+r)/2);
				`format(2*p+2,(l+r)/2+1,r);
				}
				void change(long p,long l,long r,int c)//The setting operation
				{
				`if((l==left[p])&amp;&amp;(r==right[p]))//If the range is covered, set the lazytag(that's why the operation is O(lg(n)))
				`{
				``colour[p]=1&lt;&lt;c;
				``if(l!=r)
				```lazytag[p]=c;
				``return;
				`}
				`int mid=(left[p]+right[p])/2;
				`if(lazytag[p]!=0)//Pass down the lazytag
				`{
				``change(2*p+1,left[p],mid,lazytag[p]);
				``change(2*p+2,mid+1,right[p],lazytag[p]);
				``lazytag[p]=0;
				`}
				`if(r&lt;=mid)
				``change(2*p+1,l,r,c);
				`if(l&gt;mid)
				``change(2*p+2,l,r,c);
				`if((l&lt;=mid)&amp;&amp;(r&gt;mid))
				`{
				``change(2*p+1,l,mid,c);
				``change(2*p+2,mid+1,r,c);
				`}
				`colour[p]=colour[2*p+1]|colour[2*p+2];//Update the colour state
				}
				long search(long p,long l,long r)//The asking operation
				{
				`if((lazytag[p]!=0)||(l==left[p])&amp;&amp;(r==right[p]))//Lazytag exists means the range is in the same colour, so we don't need to search
				``return colour[p];
				`int mid=(left[p]+right[p])/2;
				`if(r&lt;=mid)
				``return search(2*p+1,l,r);
				`if(l&gt;mid)
				``return search(2*p+2,l,r);
				`if((l&lt;=mid)&amp;&amp;(r&gt;mid))
				``return search(2*p+1,l,mid)|search(2*p+2,mid+1,r);
				}
				int main()
				{
				`long l,o;
				`int t;
				`scanf("%ld%d%ld",&amp;l,&amp;t,&amp;o);
				`format(0,1,l);//Build and format the segment tree
				`for(long i=0,a,b;i&lt;o;i++)
				`{
				``char s=getchar();
				``while((s!='C')&amp;&amp;(s!='P'))
				```s=getchar();
				``if(s=='C')//The setting operation
				``{
				```scanf("%ld%ld%d",&amp;a,&amp;b,&amp;t);
				```change(0,a,b,t);
				``}
				``if(s=='P')//The asking operation
				``{
				```scanf("%ld%ld",&amp;a,&amp;b);
				```long cset=search(0,a,b);
				```t=0;//Count the number of colours
				```while(cset!=0)
				```{
				````t+=cset%2;
				````cset/=2;
				```}
				```printf("%d\n",t);
				``}
				`}
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
