<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>HDU 2222 - zsz12251665's Blog</title>
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="stylesheet" type="text/css" href="/codes/style.css" />
	</head>
	<body>
		<h2 align="center">HDU 2222</h2>
		<time>2017-04-27 20:30 by zsz12251665</time>
		<h3>Problem</h3>
		<section class="btnfield">
			<a target="_blank" href="https://vjudge.net/problem/HDU-2222">vjudge</a>
			<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=2222">HDU</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>This is a practice of <abbr title="Aho-Corasick Automaton algorithm">ACAM</abbr>, a string searching algorithm which is able to search multi model strings at the same time with the help of a trie. It uses the same way as <abbr title="Knuth-Morris-Pratt string searching algorithm">KMP</abbr> does. </p>
			<p>As the first step, we put all the model strings in a trie so that we can jump to the specific character according to the character we scan. Just like I mentioned, ACAM runs as same as KMP. The next step is to calculate which character I should jump to when I find a character unmatched. So without any differences, but we use the model strings trie to replace the single model string so that it will looks like an edge. Let's call it the fail edge. At the same time, you should set up a last array to mark the last model string on the fail route (the route which jump according to the fail edge to the root) so that you can find the model string quickly. Then we scan the question string and move the pointer on the trie according to the character we read, when we reach to a point, we search the model strings accoring to the last array. That's how ACAM works. </p>
			<p>P. S. Okay! I admit that I'm preparing for my last <abbr title="Guangdong Olympiad in Informatics">GDOI</abbr>. But I do hope I can complete understand these algorithms. In my opinion, ACAM is much easier than KMP! </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<code>
				var
				`s:ansistring;
				`next:array[0..500000,1..26]of longint;
				`fail,last:array[0..500000]of longint;
				`queue:array[1..500000]of longint;
				`value:array[0..500000]of integer;
				`t,n,ans:integer;
				`size,head,foot,p,i,tmp:longint;
				begin
				`readln(t);
				`while t&gt;0 do
				``begin
				```fillchar(next,sizeof(next),0);//Format the arrays
				```fillchar(fail,sizeof(fail),0);
				```fillchar(last,sizeof(last),0);
				```fillchar(value,sizeof(value),0);
				```ans:=0;
				```readln(n);
				```size:=0;//Build the trie
				```for tmp:=1 to n do
				````begin
				`````p:=0;
				`````readln(s);
				`````for i:=1 to length(s) do
				```````if next[p,ord(s[i])-96]=0 then
				````````begin
				`````````inc(size);
				`````````next[p,ord(s[i])-96]:=size;
				`````````p:=next[p,ord(s[i])-96];
				````````end
				```````else
				````````p:=next[p,ord(s[i])-96];
				`````inc(value[p]);
				````end;
				```queue[1]:=0;//Build the fail array
				```head:=1;
				```foot:=2;
				```while head&lt;&gt;foot do
				````begin
				`````p:=queue[head];
				`````inc(head);
				`````for i:=1 to 26 do
				``````begin
				```````if next[p,i]&lt;&gt;0 then
				````````begin
				`````````queue[foot]:=next[p,i];
				`````````inc(foot);
				`````````if p=0 then
				``````````continue;
				`````````tmp:=fail[p];//If they are not matched, jump to the last match
				`````````while (tmp&gt;0)and(next[tmp,i]=0) do
				``````````tmp:=fail[tmp];
				`````````fail[next[p,i]]:=next[tmp,i];
				`````````if value[next[tmp,i]]=0 then//last is the last node of an model string
				``````````last[next[p,i]]:=last[next[tmp,i]]
				`````````else
				``````````last[next[p,i]]:=next[tmp,i];
				````````end
				```````else
				````````next[p,i]:=fail[p];
				``````end;
				````end;
				```readln(s);
				```for i:=1 to length(s) do//Scan the question string to find the model strings
				````begin
				`````while (p&lt;&gt;0)and(next[p,ord(s[i])-96]=fail[p]) do//If they are not matched, jump to the last match
				``````p:=fail[p];
				`````p:=next[p,ord(s[i])-96];
				`````tmp:=p;//Jump back to find out all model strings available
				`````while tmp&lt;&gt;0 do
				``````begin
				```````ans:=ans+value[tmp];
				```````value[tmp]:=0;
				```````tmp:=last[tmp];
				``````end;
				````end;
				```writeln(ans);
				```dec(t);
				``end;
				end.
			</code>
			<p>C++</p>
			<code>
				#include&lt;cstdio&gt;
				#include&lt;cstring&gt;//We need to use the memset function and the strlen function in cstring
				long next[500000][26],fail[500000],last[500000],queue[500000];
				int value[500000];
				char s[1000000];
				int main()
				{
				`int t;
				`for(scanf("%d",&amp;t);t&gt;0;t--)
				`{
				``memset(next,0,sizeof(next));//Format the arrays
				``memset(fail,0,sizeof(fail));
				``memset(last,0,sizeof(last));
				``memset(value,0,sizeof(value));
				``int n,ans=0;
				``scanf("%d",&amp;n);
				``for(long size=0;n&gt;0;n--)//Build the trie
				``{
				```long p=0;
				```scanf("%s",&amp;s);
				```for(int i=0,len=strlen(s);i&lt;len;i++)
				```{
				````if(next[p][s[i]-'a']==0)
				`````next[p][s[i]-'a']=++size;
				````p=next[p][s[i]-'a'];
				```}
				```value[p]++;
				``}
				``queue[0]=0;//Build the fail array
				``for(long head=0,foot=1;head!=foot;)
				``{
				```long p=queue[head++];
				```for(int i=0;i&lt;26;i++)
				````if(next[p][i]!=0)
				````{
				`````queue[foot++]=next[p][i];
				`````if(p==0)
				``````continue;
				`````long tmp=fail[p];//If they are not matched, jump to the last match
				`````while((tmp&gt;0)&amp;&amp;(next[tmp][i]==0))
				``````tmp=fail[tmp];
				`````fail[next[p][i]]=next[tmp][i];
				`````if(value[next[tmp][i]]==0)//last is the last node of an model string
				``````last[next[p][i]]=last[next[tmp][i]];
				`````else
				``````last[next[p][i]]=next[tmp][i];
				````}
				````else
				`````next[p][i]=fail[p];
				``}
				``scanf("%s",&amp;s);
				``for(long i=0,p=0,len=strlen(s);i&lt;len;i++)//Scan the question string to find the model strings
				``{
				```while((p!=0)&amp;&amp;(next[p][s[i]-'a']==fail[p]))//If they are not matched, jump to the last match
				````p=fail[p];
				```p=next[p][s[i]-'a'];
				```for(long tmp=p;tmp!=0;tmp=last[tmp])//Jump back to find out all model strings available
				```{
				````ans+=value[tmp];
				````value[tmp]=0;
				```}
				``}
				``printf("%d\n",ans);
				`}
				`return 0;
				}
			</code>
		</section>
		<script type="text/javascript" src="/add-on/article/article.js"></script>
		<script type="text/javascript" src="/add-on/highlight/highlight.js"></script>
		<script type="text/javascript" src="/add-on/math/math.js"></script>
	</body>
</html>
