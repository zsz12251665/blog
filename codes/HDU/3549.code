var
	h:array[1..15]of integer;
	des,nxt,flow:array[1..2000]of integer;
	visited:array[1..15]of boolean;
	n,m,t,ti,u,v,w,i,tmp:integer;
	ans:longint;
function dfs(p,t,f:integer):integer;// f is the maximum flow available from the start point to point p
var
	i,tmp:integer;
begin
	if p=t then// Reach the end point
		exit(f);
	visited[p]:=true;
	i:=h[p];
	while i<>-1 do
		begin
			if not visited[des[i]] and (flow[i]>0) then
				begin
					if f<flow[i] then
						tmp:=dfs(des[i],t,f)
					else
						tmp:=dfs(des[i],t,flow[i]);
					if tmp>0 then// Find a new augment path
						begin
							flow[i]:=flow[i]-tmp;// Update the edge
							if i mod 2=1 then// Update the inverse edge
								flow[i+1]:=flow[i+1]+tmp
							else
								flow[i-1]:=flow[i-1]+tmp;
							visited[p]:=false;
							exit(tmp);
						end;
				end;
			i:=nxt[i];
		end;
	visited[p]:=false;
	exit(0);
end;
begin
	read(t);
	for ti:=1 to t do
		begin
			read(n,m);
			for i:=1 to n do
				begin
					h[i]:=-1;
					visited[i]:=false;
				end;
			for i:=1 to m do
				begin
					read(u,v,w);
					des[2*i-1]:=v;// Build the edge
					nxt[2*i-1]:=h[u];
					flow[2*i-1]:=w;
					h[u]:=2*i-1;
					des[2*i]:=u;// Build the inverse edge
					nxt[2*i]:=h[v];
					flow[2*i]:=0;
					h[v]:=2*i;
				end;
			ans:=0;
			tmp:=dfs(1,n,maxint);
			while tmp>0 do// Keep trying until we cannot find a new augment path
				begin
					ans:=ans+tmp;
					tmp:=dfs(1,n,maxint);
				end;
			writeln('Case ',ti,': ',ans);
		end;
end.

#include<cstdio>
using namespace std;
int h[15],des[2000],nxt[2000],flow[2000],n,m;
bool visited[15];
int dfs(int p,int t,int f)// f is the maximum flow available from the start point to point p
{
	if(p==t)// Reach the end point
		return f;
	visited[p]=true;
	for(int i=h[p];i!=-1;i=nxt[i])
		if(!visited[des[i]] && flow[i]>0)
		{
			int tmp=dfs(des[i],t,(f<flow[i])?f:flow[i]);
			if(tmp>0)// Find a new augment path
			{
				flow[i]-=tmp;// Update the edge
				flow[(i%2==1)?i-1:i+1]+=tmp;// Update the inverse edge
				visited[p]=false;
				return tmp;
			}
		}
	visited[p]=false;
	return 0;
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int ti=1;ti<=t;++ti)
	{
		scanf("%d%d",&n,&m);
		for(int i=0;i<n;++i)
		{
			h[i]=-1;
			visited[i]=false;
		}
		for(int i=0,u,v,w;i<m;++i)
		{
			scanf("%d%d%d",&u,&v,&w);
			des[2*i]=v-1;// Build the edge
			nxt[2*i]=h[u-1];
			flow[2*i]=w;
			h[u-1]=2*i;
			des[2*i+1]=u-1;// Build the inverse edge
			nxt[2*i+1]=h[v-1];
			flow[2*i+1]=0;
			h[v-1]=2*i+1;
		}
		long ans=0;
		for(int tmp=dfs(0,n-1,65535);tmp>0;tmp=dfs(0,n-1,65535))// Keep trying until we cannot find a new augment path
			ans+=tmp;
		printf("Case %d: %ld\n",ti,ans);
	}
	return 0;
}

var
	h,pre,q:array[1..15]of integer;// The pre array is used to record from which edge the point is
	des,nxt,flow:array[1..2000]of integer;
	visited:array[1..15]of boolean;
	n,m,t,ti,u,v,w,i,tmp:integer;
	ans:longint;
function bfs(s,t:integer):integer;// f is the maximum flow available from the start point to point p
var
	head,foot,i,j,p,ans:integer;
begin
	head:=1;
	foot:=2;
	for i:=1 to n do
		begin
			pre[i]:=-1;
			visited[i]:=false;
		end;
	q[1]:=s;// Push the start point into the queue
	visited[s]:=true;
	while head<>foot do
		begin
			p:=q[head];
			head:=head mod 15+1;
			i:=h[p];
			while i<>-1 do
				begin
					if not visited[des[i]] and (flow[i]>0) then// Find a new point
						begin
							visited[des[i]]:=true;
							pre[des[i]]:=i;
							if des[i]=t then// Reach the end point
								begin
									ans:=maxint;
									j:=pre[t];// Trace back to find the bottleneck edge
									while j<>-1 do
										begin
											if ans>flow[j] then
												ans:=flow[j];
											if j mod 2=1 then
												j:=pre[des[j+1]]
											else
												j:=pre[des[j-1]];
										end;
									j:=pre[t];
									while j<>-1 do
										begin
											flow[j]:=flow[j]-ans;// Update the edge
											if j mod 2=1 then// Update the inverse edge
												begin
													flow[j+1]:=flow[j+1]+ans;
													j:=pre[des[j+1]];
												end
											else
												begin
													flow[j-1]:=flow[j-1]+ans;
													j:=pre[des[j-1]];
												end;
										end;
									exit(ans);
								end;
							q[foot]:=des[i];// Push it into the queue
							foot:=foot mod 15+1;
						end;
					i:=nxt[i];
				end;
		end;
	exit(0);
end;
begin
	read(t);
	for ti:=1 to t do
		begin
			read(n,m);
			for i:=1 to n do
					h[i]:=-1;
			for i:=1 to m do
				begin
					read(u,v,w);
					des[2*i-1]:=v;// Build the edge
					nxt[2*i-1]:=h[u];
					flow[2*i-1]:=w;
					h[u]:=2*i-1;
					des[2*i]:=u;// Build the inverse edge
					nxt[2*i]:=h[v];
					flow[2*i]:=0;
					h[v]:=2*i;
				end;
			ans:=0;
			tmp:=bfs(1,n);
			while tmp>0 do// Keep trying until we cannot find a new augment path
				begin
					ans:=ans+tmp;
					tmp:=bfs(1,n);
				end;
			writeln('Case ',ti,': ',ans);
		end;
end.

#include<cstdio>
using namespace std;
int h[15],pre[15],q[15],des[2000],nxt[2000],flow[2000],n,m;// The pre array is used to record from which edge the point is
bool visited[15];
int bfs(int s,int t)
{
	int head=0,foot=1;
	for(int i=0;i<n;++i)
	{
		pre[i]=-1;
		visited[i]=false;
	}
	q[0]=s;// Push the start point into the queue
	visited[s]=true;
	while(head!=foot)
	{
		int p=q[head];
		head=(head+1)%15;
		for(int i=h[p];i!=-1;i=nxt[i])
			if(!visited[des[i]] && flow[i]>0)// Find a new point
			{
				visited[des[i]]=true;
				pre[des[i]]=i;
				if(des[i]==t)// Reach the end point
				{
					int ans=65535;
					for(int j=pre[t];j!=-1;j=pre[des[(j%2==1)?j-1:j+1]])// Trace back to find the bottleneck edge
						if(ans>flow[j])
							ans=flow[j];
					for(int j=pre[t];j!=-1;j=pre[des[(j%2==1)?j-1:j+1]])
					{
						flow[j]-=ans;// Update the edge
						flow[(j%2==1)?j-1:j+1]+=ans;// Update the inverse edge
					}
					return ans;
				}
				q[foot]=des[i];// Push it into the queue
				foot=(foot+1)%15;
			}
	}
	return 0;
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int ti=1;ti<=t;++ti)
	{
		scanf("%d%d",&n,&m);
		for(int i=0;i<n;++i)
			h[i]=-1;
		for(int i=0,u,v,w;i<m;++i)
		{
			scanf("%d%d%d",&u,&v,&w);
			des[2*i]=v-1;// Build the edge
			nxt[2*i]=h[u-1];
			flow[2*i]=w;
			h[u-1]=2*i;
			des[2*i+1]=u-1;// Build the inverse edge
			nxt[2*i+1]=h[v-1];
			flow[2*i+1]=0;
			h[v-1]=2*i+1;
		}
		long ans=0;
		for(int tmp=bfs(0,n-1);tmp>0;tmp=bfs(0,n-1))// Keep trying until we cannot find a new augment path
			ans+=tmp;
		printf("Case %d: %ld\n",ti,ans);
	}
	return 0;
}

var
	h,d,q:array[1..15]of integer;// To enable cur optimization, add an array cur to record the latest edge we access from each point
	des,nxt,flow:array[1..2000]of integer;
	n,m,t,ti,u,v,w,i,tmp:integer;
	ans:longint;
procedure bfs(s,t:integer);
var
	head,foot,i,p:integer;
begin
	for i:=1 to n do// Reset the levels. To enable cur optimization, reset the cur array by adding "cur[i]:=h[i];" in the loop
		d[i]:=n;// d[i]=n means that you cannot reach the end point from this point
	head:=1;// Push the end point into the queue
	foot:=2;
	q[1]:=t;
	d[t]:=0;
	while head<>foot do
		begin
			p:=q[head];
			head:=head mod 15+1;
			i:=h[p];
			while i<>-1 do
				begin
					if (d[des[i]]=n) and (i mod 2=1) and (flow[i+1]>0) then// Find a new point
						begin
							d[des[i]]:=d[p]+1;// Set the level
							q[foot]:=des[i];// Push it into the queue
							foot:=foot mod 15+1;
						end;
					if (d[des[i]]=n) and (i mod 2=0) and (flow[i-1]>0) then// Find a new point
						begin
							d[des[i]]:=d[p]+1;// Set the level
							q[foot]:=des[i];// Push it into the queue
							foot:=foot mod 15+1;
						end;
					i:=nxt[i];
				end;
		end;
end;
function dfs(p,t,f:integer):integer;// f is the maximum flow available from the start point to point p
var
	i,tmp:integer;
begin
	if p=t then// Reach the end point
		exit(f);
	i:=h[p];// To enable cur optimization, use "i:=cur[p];" instead to start from the latest edge accessed
	while i<>-1 do
		begin
			if (d[des[i]]+1=d[p]) and (flow[i]>0) then
				begin
					if f<flow[i] then
						tmp:=dfs(des[i],t,f)
					else
						tmp:=dfs(des[i],t,flow[i]);
					if tmp>0 then// Find a new augment path
						begin
							flow[i]:=flow[i]-tmp;// Update the edge
							if i mod 2=1 then// Update the inverse edge
								flow[i+1]:=flow[i+1]+tmp
							else
								flow[i-1]:=flow[i-1]+tmp;
							exit(tmp);
						end;
				end;
			i:=nxt[i];
		end;
	exit(0);
end;
begin
	read(t);
	for ti:=1 to t do
		begin
			read(n,m);
			for i:=1 to n do
				h[i]:=-1;
			for i:=1 to m do
				begin
					read(u,v,w);
					des[2*i-1]:=v;// Build the edge
					nxt[2*i-1]:=h[u];
					flow[2*i-1]:=w;
					h[u]:=2*i-1;
					des[2*i]:=u;// Build the inverse edge
					nxt[2*i]:=h[v];
					flow[2*i]:=0;
					h[v]:=2*i;
				end;
			ans:=0;
			bfs(1,n);
			while d[1]<n do// Run BFS until the start point and the end point is not connected
				begin
					tmp:=dfs(1,n,maxint);
					while tmp>0 do// Keep trying until we cannot find a new augment path
						begin
							ans:=ans+tmp;
							tmp:=dfs(1,n,maxint);
						end;
					bfs(1,n);
				end;
			writeln('Case ',ti,': ',ans);
		end;
end.

#include<cstdio>
using namespace std;
int h[15],d[15],q[15],des[2000],nxt[2000],flow[2000],n,m;// To enable cur optimization, add an array cur[15] to record the latest edge we access from each point
void bfs(int s,int t)
{
	for(int i=0;i<n;++i)// Reset the levels. To enable cur optimization, reset the cur array by adding "cur[i]=h[i];" in the loop
		d[i]=n;// d[i]==n means that you cannot reach the end point from this point
	int head=0,foot=1;// Push the end point into the queue
	q[0]=t;
	d[t]=0;
	while(head!=foot)
	{
		int p=q[head];
		head=(head+1)%15;
		for(int i=h[p];i!=-1;i=nxt[i])
			if(d[des[i]]==n && flow[(i%2==1)?i-1:i+1]>0)// Find a new point
			{
				d[des[i]]=d[p]+1;// Set the level
				q[foot]=des[i];// Push it into the queue
				foot=(foot+1)%15;
			}
	}
}
int dfs(int p,int t,int f)// f is the maximum flow available from the start point to point p
{
	if(p==t)// Reach the end point
		return f;
	for(int i=h[p];i!=-1;i=nxt[i])// To enable cur optimization, use "for(int i=cur[p];i!=-1;i=nxt[i])" instead to start from the latest edge accessed
		if(d[des[i]]+1==d[p] && flow[i]>0)
		{
			int tmp=dfs(des[i],t,(f<flow[i])?f:flow[i]);
			if(tmp>0)// Find a new augment path
			{
				flow[i]-=tmp;// Update the edge
				flow[(i%2==1)?i-1:i+1]+=tmp;// Update the inverse edge
				return tmp;
			}
		}
	return 0;
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int ti=1;ti<=t;++ti)
	{
		scanf("%d%d",&n,&m);
		for(int i=0;i<n;++i)
			h[i]=-1;
		for(int i=0,u,v,w;i<m;++i)
		{
			scanf("%d%d%d",&u,&v,&w);
			des[2*i]=v-1;// Build the edge
			nxt[2*i]=h[u-1];
			flow[2*i]=w;
			h[u-1]=2*i;
			des[2*i+1]=u-1;// Build the inverse edge
			nxt[2*i+1]=h[v-1];
			flow[2*i+1]=0;
			h[v-1]=2*i+1;
		}
		long ans=0;
		for(bfs(0,n-1);d[0]<n;bfs(0,n-1))// Run BFS until the start point and the end point is not connected
			for(int tmp=dfs(0,n-1,65535);tmp>0;tmp=dfs(0,n-1,65535))// Keep trying until we cannot find a new augment path
				ans+=tmp;
		printf("Case %d: %ld\n",ti,ans);
	}
	return 0;
}

var
	h,d,q:array[1..15]of integer;// To enable gap optimization, add "cnt:array[0..15]of integer;" to count the number of points in a level
	des,nxt,flow:array[1..2000]of integer;
	n,m,t,ti,u,v,w,i,tmp:integer;
	ans:longint;
procedure bfs(s,t:integer);
var
	head,foot,i,p:integer;
begin
	for i:=1 to n do// Reset the levels
		d[i]:=n;// d[i]=n means that you cannot reach the end point from this point
	head:=1;// Push the end point into the queue
	foot:=2;
	q[1]:=t;
	d[t]:=0;
	while head<>foot do
		begin
			p:=q[head];
			head:=head mod 15+1;
			i:=h[p];
			while i<>-1 do
				begin
					if (d[des[i]]=n) and (i mod 2=1) and (flow[i+1]>0) then// Find a new point
						begin
							d[des[i]]:=d[p]+1;// Set the level
							q[foot]:=des[i];// Push it into the queue
							foot:=foot mod 15+1;
						end;
					if (d[des[i]]=n) and (i mod 2=0) and (flow[i-1]>0) then// Find a new point
						begin
							d[des[i]]:=d[p]+1;// Set the level
							q[foot]:=des[i];// Push it into the queue
							foot:=foot mod 15+1;
						end;
					i:=nxt[i];
				end;
		end;
end;
function dfs(p,t,f:integer):integer;// f is the maximum flow available from the start point to point p
var
	i,tmp:integer;
begin
	if p=t then// Reach the end point
		exit(f);
	i:=h[p];
	while i<>-1 do
		begin
			if (d[des[i]]+1=d[p]) and (flow[i]>0) then
				begin
					if f<flow[i] then
						tmp:=dfs(des[i],t,f)
					else
						tmp:=dfs(des[i],t,flow[i]);
					// To enable gap optimization, uncomment the block below
					{
					if tmp=-1 then// -1 means that a gap is found
						exit(-1);
					}
					if tmp>0 then// Find a new augment path
						begin
							flow[i]:=flow[i]-tmp;// Update the edge
							if i mod 2=1 then// Update the inverse edge
								flow[i+1]:=flow[i+1]+tmp
							else
								flow[i-1]:=flow[i-1]+tmp;
							exit(tmp);
						end;
				end;
			i:=nxt[i];
		end;
	// To enable gap optimization, uncomment the block below
	{
	dec(cnt[d[p]]);
	if cnt[d[p]]=0 then// A gap is found
		exit(-1);
	}
	d[p]:=n;
	i:=h[p];
	while i<>-1 do
		begin
			if (d[des[i]]+1<d[p]) and (flow[i]>0) then
				d[p]:=d[des[i]]+1;
			i:=nxt[i];
		end;
	exit(0);// To enable gap optimization, add "inc(cnt[d[p]]);" before exit
end;
begin
	read(t);
	for ti:=1 to t do
		begin
			read(n,m);
			for i:=1 to n do
				h[i]:=-1;
			for i:=1 to m do
				begin
					read(u,v,w);
					des[2*i-1]:=v;// Build the edge
					nxt[2*i-1]:=h[u];
					flow[2*i-1]:=w;
					h[u]:=2*i-1;
					des[2*i]:=u;// Build the inverse edge
					nxt[2*i]:=h[v];
					flow[2*i]:=0;
					h[v]:=2*i;
				end;
			ans:=0;
			bfs(1,n);
			//To enable gap optimization, uncomment the block below
			{
			for i:=0 to n do//Initialize the cnt array
				cnt[i]:=0;
			for i:=1 to n do
				inc(cnt[d[i]]);
			}
			while d[1]<n do// Run DFS until the start point and the end point is not connected
				begin
					tmp:=dfs(1,n,maxint);
					//To enable gap optimization, uncomment the block below
					{
					if tmp<0 then// Check if there is gap
						break;
					}
					ans:=ans+tmp;
				end;
			writeln('Case ',ti,': ',ans);
		end;
end.

#include<cstdio>
using namespace std;
int h[15],d[15],q[15],des[2000],nxt[2000],flow[2000],n,m;// To enable gap optimization, add an array cnt[16] to count the number of points in a level
void bfs(int s,int t)
{
	for(int i=0;i<n;++i)// Reset the levels
		d[i]=n;// d[i]==n means that you cannot reach the end point from this point
	int head=0,foot=1;// Push the end point into the queue
	q[0]=t;
	d[t]=0;
	while(head!=foot)
	{
		int p=q[head];
		head=(head+1)%15;
		for(int i=h[p];i!=-1;i=nxt[i])
			if(d[des[i]]==n && flow[(i%2==1)?i-1:i+1]>0)// Find a new point
			{
				d[des[i]]=d[p]+1;// Set the level
				q[foot]=des[i];// Push it into the queue
				foot=(foot+1)%15;
			}
	}
}
int dfs(int p,int t,int f)// f is the maximum flow available from the start point to point p
{
	if(p==t)// Reach the end point
		return f;
	for(int i=h[p];i!=-1;i=nxt[i])
		if(d[des[i]]+1==d[p] && flow[i]>0)
		{
			int tmp=dfs(des[i],t,(f<flow[i])?f:flow[i]);
			// To enable gap optimization, uncomment the block below
			/*
			if(tmp==-1)// -1 means that a gap is found
				return -1;
			*/
			if(tmp>0)// Find a new augment path
			{
				flow[i]-=tmp;// Update the edge
				flow[(i%2==1)?i-1:i+1]+=tmp;// Update the inverse edge
				return tmp;
			}
		}
	// To enable gap optimization, uncomment the block below
	/*
	--cnt[d[p]];
	if(cnt[d[p]]==0)// A gap is found
		return -1;
	*/
	d[p]=n;
	for(int i=h[p];i!=-1;i=nxt[i])
		if(d[des[i]]+1<d[p] && flow[i]>0)
			d[p]=d[des[i]]+1;
	return 0;// To enable gap optimization, add "++cnt[d[p]];" before return
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int ti=1;ti<=t;++ti)
	{
		scanf("%d%d",&n,&m);
		for(int i=0;i<n;++i)
			h[i]=-1;
		for(int i=0,u,v,w;i<m;++i)
		{
			scanf("%d%d%d",&u,&v,&w);
			des[2*i]=v-1;// Build the edge
			nxt[2*i]=h[u-1];
			flow[2*i]=w;
			h[u-1]=2*i;
			des[2*i+1]=u-1;// Build the inverse edge
			nxt[2*i+1]=h[v-1];
			flow[2*i+1]=0;
			h[v-1]=2*i+1;
		}
		long ans=0;
		bfs(0,n-1);
		// To enable gap optimization, uncomment the block below
		/*
		for(int i=0;i<=n;++i)//Initialize the cnt array
			cnt[i]=0;
		for(int i=0;i<n;++i)
			++cnt[d[i]];
		*/
		for(int tmp=dfs(0,n-1,65535);d[0]<n;tmp=dfs(0,n-1,65535))// Run DFS until the start point and the end point is not connected. To enable gap optimization, use "for(int tmp=dfs(0,n-1,65535);tmp>=0 && d[0]<n;tmp=dfs(0,n-1,65535))" instead to check if there is gap
			ans+=tmp;
		printf("Case %d: %ld\n",ti,ans);
	}
	return 0;
}
