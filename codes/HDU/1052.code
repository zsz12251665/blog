var
	copy,king,tian:array[1..1000]of integer;//The array copy is used to save a copy while doing merge sort
	n,i,ans:integer;
	kingh,tianh,kingf,tianf:integer;//kingh and kingf are the numbers of the king's best and worst horse, tianh and tianf are the number of Tian's best and worst ones
procedure msort(l,r:integer);
var
	x,y:integer;
begin
	if l>=r then
		exit;
	msort(l,(l+r) div 2);
	msort((l+r) div 2+1,r);
	copy:=king;
	x:=l;
	y:=(l+r) div 2+1;
	for i:=l to r do
		begin
			if x>(l+r) div 2 then
				begin
					king[i]:=copy[y];
					inc(y);
					continue;
				end;
			if y>r then
				begin
					king[i]:=copy[x];
					inc(x);
					continue;
				end;
			if copy[x]<copy[y] then
				begin
					king[i]:=copy[y];
					inc(y);
				end
			else
				begin
					king[i]:=copy[x];
					inc(x);
				end;
		end;
	copy:=tian;//In order to avoid using too many pointers, I sort the array king and array tian at the same time
	x:=l;
	y:=(l+r) div 2+1;
	for i:=l to r do
		begin
			if x>(l+r) div 2 then
				begin
					tian[i]:=copy[y];
					inc(y);
					continue;
				end;
			if y>r then
				begin
					tian[i]:=copy[x];
					inc(x);
					continue;
				end;
			if copy[x]<copy[y] then
				begin
					tian[i]:=copy[y];
					inc(y);
				end
			else
				begin
					tian[i]:=copy[x];
					inc(x);
				end;
		end;
end;
begin
	read(n);
	while n<>0 do
		begin
			for i:=1 to n do
				read(tian[i]);
			for i:=1 to n do
				read(king[i]);
			msort(1,n);
			ans:=0;
			kingh:=1;
			tianh:=1;
			kingf:=n;
			tianf:=n;
			for i:=1 to n do//The greedy part
				begin
 					if tian[tianf]>king[kingf] then
						begin
							inc(ans);
							dec(tianf);
							dec(kingf);
							continue;
						end;
					if tian[tianf]<king[kingf] then
						begin
							dec(ans);
							dec(tianf);
							inc(kingh);
							continue;
						end;
					if tian[tianh]>king[kingh] then
						begin
							inc(ans);
							inc(tianh);
							inc(kingh);
							continue;
						end;
					if tian[tianf]<king[kingh] then
						dec(ans);
					if tian[tianf]>king[kingh] then
						inc(ans);
					dec(tianf);
					inc(kingh);
				end;
			writeln(ans*200);
			read(n);
		end;
end.

#include<cstdio>
#include<cstring>//We need to use the memcpy function in cstring
int copy[1000],king[1000],tian[1000];//The array copy is used to save a copy while doing merge sort
void msort(int l,int r)
{
	if(l>=r)
		return;
	msort(l,(l+r)/2);
	msort((l+r)/2+1,r);
	memcpy(copy,king,sizeof king);
	for(int i=l,x=l,y=(l+r)/2+1;i<=r;i++)
	{
		if(x>(l+r)/2)
		{
			king[i]=copy[y++];
			continue;
		}
		if(y>r)
		{
			king[i]=copy[x++];
			continue;
		}
		if(copy[x]<copy[y])
			king[i]=copy[y++];
		else
			king[i]=copy[x++];
	}
	memcpy(copy,tian,sizeof tian);//In order to avoid using too many pointers, I sort the array king and array tian at the same time
	for(int i=l,x=l,y=(l+r)/2+1;i<=r;i++)
	{
		if(x>(l+r)/2)
		{
			tian[i]=copy[y++];
			continue;
		}
		if(y>r)
		{
			tian[i]=copy[x++];
			continue;
		}
		if(copy[x]<copy[y])
			tian[i]=copy[y++];
		else
			tian[i]=copy[x++];
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	while(n!=0)
	{
		for(int i=0;i<n;i++)
			scanf("%d",&tian[i]);
		for(int i=0;i<n;i++)
			scanf("%d",&king[i]);
		msort(0,n-1);
		int ans=0,kingh=0,tianh=0,kingf=n-1,tianf=n-1;//kingh and kingf are the numbers of the king's best and worst horse, tianh and tianf are the number of Tian's best and worst ones
		for(int i=0;i<n;i++)//The greedy part
		{
			if(tian[tianf]>king[kingf])
			{
				ans++;
				tianf--;
				kingf--;
				continue;
			}
			if(tian[tianf]<king[kingf])
			{
				ans--;
				tianf--;
				kingh++;
				continue;
			}
			if(tian[tianh]>king[kingh])
			{
				ans++;
				tianh++;
				kingh++;
				continue;
			}
			if(tian[tianf]<king[kingh])
				ans--;
			if(tian[tianh]>king[kingh])
				ans++;
			tianf--;
			kingh++;
		}
		printf("%d\n",ans*200);
		scanf("%d",&n);
	}
	return 0;
}